local module = {
	canPlay = {
		'rbxassetid://13158735106', 
		'rbxassetid://13158734943', 
		'rbxassetid://13158735037',
		--'rbxassetid://13159969353'
	},

	headshotid = 'rbxassetid://16537337310', -- RIVALS | Headshot SoundId
	bodyshotid = 'rbxassetid://13110130082' -- RIVALS | Bodyshot SoundId
}

--[[ ADDING NEW SKINS ]|

- Copying rivals ItemLibrary to -- << TODO:Econ/WeaponTypes >>
- Run Clipboard script and pasting to -- << TODO:Econ/AnimSound >>
- Put new 'add_animations' from AnimLib to -- << TODO:Econ/Anim >>
- Put new 'add_viewmodel' from ItemLibrary to  -- << TODO:Econ/Skin >>
- Put 'add_cosmetic_upvr' from CosmeticLibrary to -- << TODO:Econ/SkinInfo >>


-- [[ ADDING NEW WRAPS ]|

- Put 'add_wrap' from CosmeticLibrary to -- << TODO:Econ/UTILS.WRAPPER_MOD.txt >>

- / Not Necessary: Extrafuncs /

-- [[ ADDING NEW ITEMS ]|

- Primary, Secondary, Melee, Utility from ItemLib to WeaponTypes 'str' ]]

----------- [ Services ] -----------

local players = game:GetService'Players'
local run = game:GetService'RunService'
local ss = game:GetService'SoundService'
local uis = game:GetService'CoreGui'
local cs = game:GetService'TextChatService'
local rep = game:GetService'ReplicatedStorage'
local workspace = game:GetService'Workspace'

----------- [ Player Assets ] -----------

local plr = players.LocalPlayer
local scripts = plr.PlayerScripts
local assets = scripts:WaitForChild'Assets'

local vms = workspace.ViewModels.FirstPerson

local misc = assets.Misc
local skins = assets.ViewModels

local muzzles = misc.MuzzleFlashes
local deflectiveactive = misc.DeflectActiveEffects
local deflecthit = misc.DeflectHitEffects

local weaponSounds = scripts.Modules.ClientReplicatedClasses.ClientFighter.ClientItem
local hitmarkerSounds = weaponSounds.ClientViewModel

----------- [ Main ] -----------

local updatedCharFuncs = {}
local ANIM_TO_NAME = {
	inspect = 'Inspect',
	equip = 'Equip',
	idle = 'Idle',
	sprint = 'Sprint',
	rareinspect = 'RareInspect'
}

-- // Loading

if _G.hd then
	_G.hd:Disconnect()
end

local RELOAD = {}
local UTILS = {}
local TOTAL_UTILS = 0
local __REQUIRE = function(name:string, URL:string)
	TOTAL_UTILS += 1

	task.spawn(function()
		local REQUIRED_URL = not RELOAD[name] and _G[name] or loadstring(game:HttpGet(URL))()
		UTILS[name] = REQUIRED_URL;
		_G[name] = REQUIRED_URL;

		TOTAL_UTILS -= 1
	end)
end

local URL_ROOT = 'https://raw.githubusercontent.com/C0XNEcon/Econ3xC/refs/heads/main/'
__REQUIRE('SKIN_MOD',`{URL_ROOT}Skin`);
__REQUIRE('RIVALS_UTILS',`{URL_ROOT}UtilityFake`);
__REQUIRE('SKIN_INFO',`{URL_ROOT}SkinInfo`);
__REQUIRE('SKIN_SOUND_CODE',`{URL_ROOT}AnimSound`);
__REQUIRE('WEAPON_TYPES',`{URL_ROOT}WeaponTypes`);
__REQUIRE('EXTRA_FUNCS',`{URL_ROOT}ExtraFunc`);
__REQUIRE('WRAPPER_MOD',`{URL_ROOT}Wrapper.txt`);
__REQUIRE('ECON_UI',`{URL_ROOT}Econ%20UI.txt`)

if TOTAL_UTILS > 0 then repeat run.Stepped:Wait() until TOTAL_UTILS == 0 end

-- // Global

_G.ourrrs = _G.ourrrs or {}

_G.lt = tick()
_G.nametoid = _G.nametoid or {}
_G.skinanim = _G.skinanim or {}
_G.applied = _G.applied or {}
_G.ourAnims = _G.ourAnims or {}
_G.skinToAnimCon = _G.skinToAnimCon or {}
_G.headshotFuncs = {}

_G.hd = hitmarkerSounds.ChildAdded:Connect(function(v : Sound)
	if v:IsA('Sound') and v.SoundId == module.headshotid then
		for _, v in _G.headshotFuncs do
			v()
		end
	end
end)

_G.r = run
_G.saved = _G.saved or {}
_G.is = _G.is or {};
_G.at = _G.at or {};
_G.ogim = _G.ogim or {}
_G.inf = _G.inf or {
	idtoname = {}
}

-- // ChatFunc

if _G.pl then
	_G.pl:Disconnect()
else
	_G.topre = {}
end

_G.pl = cs.SendingMessage:Connect(function(msg)
	msg = msg.Text:lower()
	if msg:sub(1,1) == 'a' then
		local anim = msg:sub(2,-1)
		local t = _G.topre[vms:GetChildren()[1]]

		for name, v in t do
			if name:lower() == anim:lower() then
				v:play({
					reference = t.idle.tbl.anim,
					silenceReference = 1,
					unsilenceAfter = 1,
				})
			end
		end
	end
end)

-- // Rest

local sound = Instance.new('Sound')
sound.Volume = 1
sound.SoundId = 'rbxassetid://6895079853'

local function playSound(sp, rep, vol)
	local new = (rep or sound):Clone()
	new.Parent = workspace
	new.Volume = vol or 1
	new.PlaybackSpeed = sp or 1
	new:Play()

	new.Ended:Connect(function()
		new:Destroy()
	end)
end

playSound()

-- // UI

local UI_WINDOW = UTILS.ECON_UI:CreateWindow({
	Name = 'Econ Skinchanger',
	Icon = nil,
	LoadingTitle = '',
	LoadingSubtitle = "by ConePartyy",
	Theme = "AmberGlow", 

	DisableEconFieldPrompts = true,
	DisableBuildWarnings = true,

	ConfigurationSaving = {
		Enabled = true,
		FolderName = 'cone',
		FileName = "econ"
	},

	Discord = {
		Enabled = false,
		Invite = "acv8tdb8",
		RememberJoins = true
	},

	KeySystem = false,
	KeySettings = {
		Title = 'Econ | Password',
		Subtitle = '',
		Note = nil,
		FileName = 'econK',
		SaveKey = true,
		GrabKeyFromSite = true,
		Key = {}
	}
})

-- // WRAP CHANGER CONTROL

local wrapSkinInfo = {}

function readSkinFile()
	local rf = isfile'cSkin'
	if rf then
		local splits = readfile'cSkin':split'�'
		for _, v in splits do
			local inf = v:split'`'
			wrapSkinInfo[inf[1]] = {
				wrap = inf[2],
				inverted = inf[3] == 'true'
			}
		end
	else
		writefile('cSkin', '')
	end
end

function writeSkinFile()
	local str = ''
	for skin, inf in wrapSkinInfo do
		str..=skin..'`'..(inf.wrap or 'None')..'`'..tostring(inf.inverted)..'�'
	end
	writefile('cSkin', str)
end

readSkinFile()

-- // Skinchanger Filing

local weaponToButton = {}
local charapb = {}

local cid = plr.UserId

function readsfile()
	local rf = isfile('cSkinchanged') 
	if rf then
		local splits = string.split(readfile('cSkinchanged'), '�')
		for _, v in pairs(splits) do
			local inf = string.split(v, '`')
			if weaponToButton[inf[1]] then
				_G.toskin[inf[1]] = inf[2]
				weaponToButton[inf[1]]:Set({inf[2]}, true)
			elseif tonumber(inf[1]) and not inf[2] then
				cid = tonumber(inf[1])
				charapb:Set(cid)
			end
		end
	else
		writefile('cSkinchanged', '')
	end
end

function writesfile()
	local str = tostring(cid)..'.'
	for weapon, skin in pairs(_G.toskin) do
		str..=weapon..'`'..skin..'�'
	end
	writefile('cSkinchanged', str)
end

-- // Rest

local ps = plr.PlayerScripts:WaitForChild('Assets')

local function gt()
	local inf = wrapSkinInfo[string.split(cw.Name, ' - ')[3]]
	UTILS.WRAPPER_MOD:wrapThis(cw, (inf and inf.wrap or 'None'), (inf and inf.inverted), ps.ViewModels, ps.WrapTextures)
end

local function check(v)
	if string.find(v.Name, plr.Name) then
		local rest = string.split(v.Name, ' - ')

		cw = v
		gt()
	end
end

if vms:GetChildren()[1] then
	check(vms:GetChildren()[1])
end

-- // REST

local to = {
	'Primary', 'Secondary', 'Melee', 'Utility'
}

local toskin = {}
_G.toskin = toskin

local initConnections = {}

-- // CHARACTER CHANGER

local p = game:GetService('Players')

local loadedids = {}

local ltagcon = nil
local lll = nil

-- // Character Changer

local dn = (plr.DisplayName or plr.Name)..(plr.HasVerifiedBadge and ' '..utf8.char(0xE000) or '')
local usn = plr.Name

local function cchar(id)
	task.spawn(function()
		local id = typeof(id) == 'number' and id or cid
		if not id then return end

		local lid = loadedids[id]

		local suc, z = false, 'Lid Exists'
		if not (lid and lid.apr) then
			suc, z = pcall(function()
				return p:GetCharacterAppearanceAsync(id)
			end)
		end

		local cha = lid and lid.apr or suc and z

		if not cha then UTILS.ECON_UI:Notify({Title = 'CharacterAppearance Error', Content = tostring(z), Duration = 10, Image = 'search-x'}) return end

		local char = plr.Character

		-- // REST

		local inff = nil
		task.spawn(function()
			-- // VISUALS

			for _, v in updatedCharFuncs do
				v()
			end

			local suc, z = false, 'Lid Exists'
			if not lid or not lid.inff then
				suc, z = pcall(function()
					return game:GetService('UserService'):GetUserInfosByUserIdsAsync({id})
				end)
			end

			local inf = lid and lid.inff or suc and z

			if not inf or typeof(inf) == 'boolean' then UTILS.ECON_UI:Notify({Title = 'Name,Displayname Error', Content = tostring(z), Duration = 10, Image = 'search-x'}) return end

			inff = inf
			loadedids[id].inff = inf

			if ltagcon then
				for _, v in pairs(ltagcon) do
					v:Disconnect()
				end
			end

			if lll then
				lll:Disconnect()
			end

			if inf and inf[1] then
				inf = inf[1]

				local root = char:WaitForChild('HumanoidRootPart')

				local function tagfunc(tag)
					if not tag or tag.Name ~= 'Nametag' then return end

					if ltagcon then
						for _, v in pairs(ltagcon) do
							v:Disconnect()
						end
					end

					local frame = tag.Frame or tag:WaitForChild('Frame')
					local ff = frame.Player
					local un = ff.Username

					local function hn()
						dn = (tostring(inf.DisplayName) or inf.Username)..(inf.HasVerifiedBadge and ' '..utf8.char(0xE000) or '')
						usn = inf.Username
						ff.Text = dn
						un.Text = inf.DisplayName and '@'..inf.Username or ''
					end

					hn()

					ltagcon = {}

					table.insert(ltagcon, ff:GetPropertyChangedSignal('Text'):Connect(hn))
					table.insert(ltagcon, tag:GetPropertyChangedSignal('Parent'):Once(function()
						for _, v in pairs(ltagcon) do
							v:Disconnect()
						end
					end))

					for _, v in pairs(ltagcon) do
						table.insert(initConnections, v)
					end
				end

				tagfunc(root:FindFirstChild('Nametag'))
				lll = root.ChildAdded:Connect(tagfunc)
				table.insert(initConnections, lll)
			end
		end)

		loadedids[id] = {
			apr = cha,
		}

		task.spawn(function()
			local suc, z = false, 'Lid Exists'
			if not (lid and lid.ap) then
				suc, z = pcall(function()
					return p:GetHumanoidDescriptionFromUserId(id)
				end)
			end

			local ap = lid and lid.ap or suc and z

			if not ap then UTILS.ECON_UI:Notify({Title = 'FaceDecal Error', Content = tostring(z), Duration = 10, Image = 'search-x'}) return end

			if not ap then
				ap = {
					Face = 0
				}
			end

			loadedids[id].ap = ap

			local face = ap.Face
			local faceid = "rbxthumb://type=Asset&w=768&h=432&id="..face

			local head = char:WaitForChild('Head')
			for _, v in pairs(head:GetChildren()) do
				if v.Name == 'face' then
					v:Destroy()
				end
			end

			local newface = Instance.new('Decal', head)
			newface.Name = 'face'
			newface.Texture = face ~= 0 and faceid or 'rbxasset://textures/face.png'
		end)

		local function caa(characterModel, accessory)
			task.spawn(function()
				local accessoryAttachment = accessory:FindFirstChildWhichIsA("Attachment", true)
				if not accessoryAttachment then
					warn("No attachments found in accessory. Accessory was not attached.")
					return
				end

				local attachmentName = accessoryAttachment.Name
				local attachTo = nil

				local st = tick()
				repeat run.Stepped:Wait() attachTo = characterModel:FindFirstChild(attachmentName, true) until attachTo

				if not attachTo or not attachTo:IsA("Attachment") then
					warn(string.format("No attachment named %s found in character. Accessory was not attached.", attachmentName))
					return
				end

				local Handle = accessory:FindFirstChild("Handle")
				if not Handle then
					warn("Attachment has no handle. Accessory was not attached.")
					return
				end

				Handle.CFrame = attachTo.WorldCFrame * accessoryAttachment.CFrame:Inverse()

				local nc = Instance.new('WeldConstraint', Handle)
				nc.Part0 = Handle
				nc.Part1 = attachTo.Parent

				accessory.Parent = characterModel
			end)
		end

		local names = {'Shirt', 'Pants', 'ShirtGraphic', 'Accessory'}

		local function hand(v)
			if table.find(names, v.ClassName) then
				task.defer(function()
					v:Destroy()
				end)
			elseif v.ClassName == 'BodyColors' then
				local bc = cha:FindFirstChild('Body Colors') :: BodyColors
				if bc then
					v.HeadColor3 = bc.HeadColor3
					v.TorsoColor3 = bc.TorsoColor3
					v.LeftArmColor3 = bc.LeftArmColor3
					v.LeftLegColor3 = bc.LeftLegColor3
					v.RightArmColor3 = bc.RightArmColor3
					v.RightLegColor3 = bc.RightLegColor3

					local to = {
						RightUpperArm = bc.RightArmColor3,
						RightLowerArm = bc.RightArmColor3,
						RightHand = bc.RightArmColor3,

						LeftUpperArm = bc.LeftArmColor3,
						LeftLowerArm = bc.LeftArmColor3,
						LeftHand = bc.LeftArmColor3,

						Head = bc.HeadColor3,
						UpperTorso = bc.TorsoColor3,
						LowerTorso = bc.TorsoColor3,

						RightUpperLeg = bc.RightLegColor3,
						RightLowerLeg = bc.RightLegColor3,
						RightFoot = bc.RightLegColor3,

						LeftUpperLeg = bc.LeftLegColor3,
						LeftLowerLeg = bc.LeftLegColor3,
						LeftFoot = bc.LeftLegColor3,
					}

					for piece, colr in pairs(to) do
						task.spawn(function()
							char:WaitForChild(piece).Color = colr
						end)
					end
				end
			end
		end

		for _, v : BodyColors in pairs(char:GetChildren()) do
			hand(v)
		end

		local con2
		local con = char.ChildAdded:Connect(function(v)
			if not table.find(_G.ourrrs, v) then
				hand(v)
			end
		end)

		table.insert(initConnections, con)
		table.insert(initConnections, char:GetPropertyChangedSignal('Parent'):Once(function()
			if con then
				con:Disconnect()
			end

			if con2 then
				con2:Disconnect()
			end
		end))

		local function h2(v)
			if table.find(names, v.ClassName) then
				if v:IsA('Accessory') then
					local v = v:Clone()
					for _, v in pairs(v:GetChildren()) do
						if v:IsA('BasePart') then
							v.CanCollide = false
							v.CanQuery = false
							v.CanTouch = false
							v.CollisionGroup = 'Players'
							v.Massless = true
						end
					end

					table.insert(_G.ourrrs, v)
					caa(char, v)
				else 
					local cl = v:Clone() :: BodyColors
					table.insert(_G.ourrrs, cl)
					cl.Parent = char
				end
			end
		end

		for _, v in pairs(cha:GetChildren()) do
			h2(v)
		end

		con2 = cha.ChildAdded:Connect(h2)
		table.insert(initConnections, con2)
	end)
end

-- // REST

local READ_FILE = false

for t, weapons in UTILS.WEAPON_TYPES.typeToWeapons do
	local gameplayTab = UI_WINDOW:CreateTab(to[t])

	if t == 1 then
		local sec = gameplayTab:CreateSection'Character Changer'

		local charchanger = gameplayTab:CreateInput({
			Name = 'Player ID / Name',
			CurrentValue = tostring(cid),
			PlaceholderText = 'ConePartyy',
			RemoveTextAfterFocusLost = false,
			Flag = 'appearancechangerid',
			Callback = function(t)
				local suc, z = false, 'Lid Exists'
				if not (tonumber(t) or tonumber(_G.nametoid[t])) then
					suc, z = pcall(function()
						return p:GetUserIdFromNameAsync(t)
					end)
				end

				local id = tonumber(t) or tonumber(_G.nametoid[t] or suc and z)

				if not id then UTILS.ECON_UI:Notify({Title = 'Name>ID Error', Content = tostring(z), Duration = 10, Image = 'search-x'}) return end

				if id then
					_G.nametoid[t] = id
					cid = id
					cchar(id)

					if redfile then
						writesfile()
					end
				end
			end,
		})

		charapb = charchanger

		local visualSection = gameplayTab:CreateSection('Wrap Changer - Hold a weapon')

		local selectedWrap = 'None'
		local selectedWeapon = 'Assault Rifle'
		local wrapsX = {'None'}
		local inverted = false

		for wrap, v in UTILS.WRAPPER_MOD:getAll() do
			table.insert(wrapsX, wrap)
		end

		function updateSkin()
			local name = string.split(cw.Name, ' - ')[3]
			wrapSkinInfo[name] = {
				wrap = selectedWrap,
				inverted = inverted,
			}

			writeSkinFile()
			gt()
		end

		local typeWrap
		local wrapDropdown = gameplayTab:CreateDropdown({
			Name = 'Wrap',
			Options = wrapsX,
			CurrentOption = {selectedWrap},
			MultipleOptions = false,
			Ext = true,
			Flag = 'wcwcdropdown',
			Callback = function(Options, nosound)
				selectedWrap = Options[1]

				if not nosound and not (not vms or #vms:GetChildren() == 0) then
					updateSkin()
				elseif not nosound then
					UTILS.ECON_UI:Notify({
						Title = 'Error',
						Content = 'Hold a weapon to change your wrap', 
						Image = 6026568210,
						Duration = 2,
					})
				end
			end,
		})

		local wrapz = {'none'}
		for wrap, v in UTILS.WRAPPER_MOD:getAll() do
			table.insert(wrapz, wrap:lower())
		end

		typeWrap = gameplayTab:CreateInput({
			Name = 'Type Wrap',
			CurrentValue = selectedWrap,
			PlaceholderText = selectedWrap,
			RemoveTextAfterFocusLost = true,
			Ext = true,
			Flag = 'wcwcinput',
			Callback = function(txt, nosound)
				if table.find(wrapz, txt:lower()) then
					local realWrap = 'None'
					for w, v in UTILS.WRAPPER_MOD:getAll() do
						if w:lower() == txt:lower() then
							realWrap = w
						end
					end

					if not (not vms or #vms:GetChildren() == 0) then
						wrapDropdown:Set({realWrap}, nosound)
					end

					selectedWrap = realWrap

					if not nosound and not (not vms or #vms:GetChildren() == 0) then
					elseif not nosound then
						UTILS.ECON_UI:Notify({
							Title = 'Error',
							Content = 'Hold a weapon to change your wrap', 
							Image = 6026568210,
							Duration = 2,
						})
					end
				end
			end,
		})

		local invertedToggle = gameplayTab:CreateToggle({
			Name = 'Inverted',
			CurrentValue = false,
			Ext = true,
			Flag = "invtoggle",
			Callback = function(Value, nosound)
				inverted = Value

				if not nosound and not (not vms or #vms:GetChildren() == 0) then
					updateSkin()
				elseif not nosound then
					UTILS.ECON_UI:Notify({
						Title = 'Error',
						Content = 'Hold a weapon to change your wrap', 
						Image = 6026568210,
						Duration = 2,
					})
				end
			end,
		})

		table.insert(initConnections, vms.ChildAdded:Connect(function(v)
			check(v)

			if not v:HasTag('Changed') then
				for _, v in pairs(_G.toskin) do
					_G.ac(v)
				end
			end

			local n = string.split(cw.Name, ' - ')[3]
			local inf = wrapSkinInfo[n]
			visualSection:Set(n and 'Wrap Changer - '..n or 'Wrap Changer - Hold a weapon')
			task.spawn(function()
				typeWrap:Set(inf and inf.wrap or 'None', 1)
			end)

			task.spawn(function()
				invertedToggle:Set(inf and inf.inverted, 1)	
			end)
		end))

		table.insert(initConnections, vms.ChildRemoved:Connect(function(v)
			if not vms or #vms:GetChildren() == 0 then
				visualSection:Set('Wrap Changer - Hold a weapon')
				task.spawn(function()
					typeWrap:Set('None', 1)
				end)

				task.spawn(function()
					invertedToggle:Set(false, 1)	
				end)
			end
		end))

		local function frcheck()
			local v = vms:GetChildren()[1]
			if v then
				check(v)

				local n = string.split(cw.Name, ' - ')[3]
				local inf = wrapSkinInfo[n]
				visualSection:Set(n and 'Wrap Changer - '..n or 'Wrap Changer - Hold a weapon')
				task.spawn(function()
					typeWrap:Set(inf and inf.wrap or 'None', 1)
				end)

				task.spawn(function()
					invertedToggle:Set(inf and inf.inverted, 1)	
				end)
			end
		end

		_G.frr = frcheck
	end

	local visualSection = gameplayTab:CreateSection'Weapons'

	for skin, v in weapons do
		skin = v
		v = UTILS.SKIN_INFO.skinInfo[v]

		if v then
			local ov = table.clone(v)
			v = {'Dont Change'}
			for _, v2 in pairs(ov) do
				table.insert(v, v2)
			end

			local selectedSkin = [[Dont Change]]
			local drop = gameplayTab:CreateDropdown({
				Name = skin,
				Options = v,
				CurrentOption = {[[Dont Change]]},
				MultipleOptions = false,
				Flag = skin,
				Callback = function(Options, nosound, nowrite)
					selectedSkin = Options[1]

					_G.toskin[skin] = Options[1]

					if not nosound then
						_G.ac(selectedSkin)
						if READ_FILE then
							writesfile()
						end
					end
				end,
			})

			weaponToButton[skin] = drop
		end
	end
end

local going = true

plr:SetAttribute('OriginalPositionb', nil)
plr:SetAttribute('OriginalPositionb', true)

table.insert(initConnections, plr:GetAttributeChangedSignal('OriginalPositionb'):Connect(function()
	for _, v in initConnections do
		v:Disconnect()
	end

	going = false
	return
end))

local relAnim = rep.Modules.AnimationLibrary

local soundGroup = ss:FindFirstChild('Zero') or Instance.new('SoundGroup', ss)
local animStorage = uis:FindFirstChild('AnimsEcon') or Instance.new('Folder', uis)
animStorage.Name = 'AnimsEcon'
soundGroup.Name = 'Zero'

local soundOn = true

-- // Global

if _G.soundCon then
	_G.soundCon:Disconnect()
end

if _G.volumeC then
	_G.volumeC:Disconnect()
end

_G.volumeC = ss.Other:GetPropertyChangedSignal('Volume'):Connect(function()
	if soundOn then
		soundGroup.Volume = ss.Other.Volume
	end
end)

_G.soundCon = weaponSounds.ChildAdded:Connect(function(s)
	if (not table.find(module.canPlay, s.SoundId) or s.PlaybackSpeed == .5) and not s:HasTag('IsOurs') then
		s.SoundGroup = soundGroup
	end
end)

-- // Main

local toMuzzle = {
	Minigun = 'Minigun',
	Spray = 'Spray',
}

for _, v in skins.Weapons:GetChildren() do
	toMuzzle[v.Name] = toMuzzle[v.Name] or 'Default'
end

task.spawn(function()
	local prelo = {}
	for _, v in _G.toskin do
		table.insert(prelo, UTILS.SKIN_MOD.viewmodels[v].image)
	end
	game:GetService('ContentProvider'):PreloadAsync(prelo)
end)

function findSkin(name)
	for _, v in skins:GetChildren() do
		for _, v in v:GetChildren()do
			if v.Name == name then return v end
		end
	end
end

-- // Weapons ViewProfile UI Changer

local prcons = {}
local pacons = {}
local pa2cons = {}
local sidecons = {}

local is = _G.selectChanged

function getIcon()
	local content = nil
	local isReady = nil
	local id = cid or plr.UserId
	local s = _G.saved[id]

	if s then
		content = s.content
		isReady = s.isReady
	else
		local suc, c, r = pcall(function()
			return game:GetService('Players'):GetUserThumbnailAsync(id, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420)
		end)

		if not suc or not r then UTILS.ECON_UI:Notify({Title = 'PlrIcon Error', Content = tostring(c), Duration = 10, Image = 'search-x'}) return end

		content = c
		r = r

		_G.saved[id] = {
			content = c, isReady = r
		}
	end

	return content, isReady
end

-- // FUNCTIONS

function idtplr(id)
	local d = _G.inf.idtoname[id]
	if d then return d end

	for _, v in players:GetPlayers() do
		if v.UserId == id then
			_G.inf.idtoname[id] = v
			return v
		end
	end
end

-- // Character UI

task.spawn(function()
	local MAIN_UI = plr.PlayerGui:WaitForChild('MainGui')
	local pages = MAIN_UI.MainFrame.Pages

	local function checkfor(v)
		if v.Name == 'ViewProfile' then
			if prcons then
				for _, v in pairs(prcons) do
					v:Disconnect()
				end
			end

			local _active = v:WaitForChild('Active')
			local __player = _active.Player

			local _display = __player.DisplayName
			local _username = __player.Username
			local _headshot = __player.Headshot
			local list = __player.FavoriteWeapons

			local content, isReady = getIcon()

			if not _G.ogim[_headshot] then
				_G.ogim[_headshot] = _headshot.Image
			end

			local function hn(changedim)
				if string.find(_G.ogim[_headshot], tostring(plr.UserId)) then
					_display.Text = dn
					_username.Text = '@'..usn
					if isReady and _headshot.Image ~= content then
						_G.ignorenext = true
						_headshot.Image = content
					end
				else
					local str = string.sub(_G.ogim[_headshot], 56, -1)
					local id = tonumber(string.sub(str, 1, string.find(str, '&')-1))
					if id and idtplr(id) then
						_username.Text = '@'..idtplr(id).Name
					end
				end
			end

			prcons = {}

			if not is then
				local function handle(v)
					task.spawn(function()
						local b = v.Name == 'PickWeaponSlot' and v:WaitForChild('Button')
						if b and b:FindFirstChild('Icon') and b.Icon:FindFirstChild('Picture') then
							b = b.Icon.Picture
							b.Name = 'OPic'

							local function calc()
								if string.find(_G.ogim[_headshot], tostring(plr.UserId)) then
									local ts = UTILS.SKIN_MOD.its[b.Image]
									local tog = UTILS.SKIN_INFO.skinToOg[ts] or ts
									local tocur = _G.toskin[tog]
									if tocur and tocur ~= 'Dont Change' then
										b.Image = UTILS.SKIN_MOD.viewmodels[tocur].image
									end
								end
							end

							table.insert(updatedCharFuncs, calc)
							calc()

							local z = b:GetPropertyChangedSignal('Image'):Connect(calc)
							table.insert(prcons, z)
							table.insert(initConnections, z)
						end
					end)
				end

				for _, v in pairs(list:GetChildren()) do
					handle(v)
				end

				table.insert(prcons, list.ChildAdded:Connect(handle))
			end

			hn()

			table.insert(updatedCharFuncs, hn)
			table.insert(prcons, _headshot:GetPropertyChangedSignal('Image'):Connect(function()
				if not _G.ignorenext then
					_G.ogim[_headshot] = _headshot.Image
				else
					_G.ignorenext = false
				end

				hn(true)
			end))

			table.insert(prcons, _username:GetPropertyChangedSignal('Text'):Connect(function()
				hn(true)
			end))

			table.insert(prcons, _display:GetPropertyChangedSignal('Text'):Connect(function()
				hn(true)
			end))

			for _, v in pairs(prcons) do
				table.insert(initConnections, v)
			end 
		end
	end

	if pages:FindFirstChild('ViewProfile') then
		checkfor(pages.ViewProfile)
	end

	table.insert(initConnections, pages.ChildAdded:Connect(checkfor))

	-- // Lobby Icon Party #1

	local lobby = MAIN_UI.MainFrame.Lobby

	if pacons then
		for _, v in pairs(pacons) do
			v:Disconnect()
		end
	end

	pacons = {}

	local function cf(v)
		if v.Name == 'Party' then
			local bd = v.BottomDisplay
			local con = bd.Container

			local function h(v : Frame)
				if v.Name == 'PartyMemberSlot' and v.LayoutOrder == 1 then
					local ico = v.Button.Icon
					ico.Image = getIcon()

					table.insert(updatedCharFuncs, function()
						ico.Image = getIcon()
					end)

					local z = ico:GetPropertyChangedSignal('Image'):Connect(function()
						ico.Image = getIcon()
					end)

					table.insert(pacons, z)
					table.insert(initConnections, z)
				end
			end


			local z = con.ChildAdded:Connect(h)
			table.insert(pacons, z)
			table.insert(initConnections, z)

			for _, v in pairs(con:GetChildren()) do
				h(v)
			end
		end
	end

	if lobby:FindFirstChild('Party') then
		cf(lobby.Party)
	end

	table.insert(initConnections, lobby.ChildAdded:Connect(cf))

	-- // Lobby Icon Party #2

	if pa2cons then
		for _, v in pairs(pa2cons) do
			v:Disconnect()
		end
	end

	pa2cons = {}

	local function cc(v)
		if v.Name == 'Party' then
			local b = v.Members

			local function h(v : Frame)
				if v.Name == 'PartyMemberBigSlot' and v.LayoutOrder == 1 then
					local ico = v.Icon
					ico.Image = getIcon()

					local _display = v.DisplayName
					local _username = v.Username

					local function hn()
						_display.Text = dn
						_username.Text = '@'..usn
						ico.Image = getIcon()
					end

					local function add(con)
						table.insert(pa2cons, con)
						table.insert(initConnections, con)
					end

					hn()
					add(_username:GetPropertyChangedSignal('Text'):Connect(hn))
					add(_display:GetPropertyChangedSignal('Text'):Connect(hn))
					add(ico:GetPropertyChangedSignal('Image'):Connect(hn))

					table.insert(updatedCharFuncs, hn)
				end
			end

			local z = b.ChildAdded:Connect(h)
			table.insert(pa2cons, z)
			table.insert(initConnections, z)

			for _, v in pairs(b:GetChildren()) do
				h(v)
			end
		end
	end

	if pages:FindFirstChild('Party') then
		cc(pages.Party)
	end

	table.insert(initConnections, pages.ChildAdded:Connect(cc))

	-- // Side Party

	local lobby = MAIN_UI.MainFrame.Lobby

	if sidecons then
		for _, v in pairs(sidecons) do
			v:Disconnect()
		end
	end

	sidecons = {}

	local function h(v)
		if v.Name == 'SideParty' then
			local con = v.Container

			local function h(v : Frame)
				if v.Name == 'PartyMemberSlot' and v.LayoutOrder == -1 then
					local ico = v.Button.Icon
					ico.Image = getIcon()

					table.insert(updatedCharFuncs, function()
						ico.Image = getIcon()
					end)

					local function add(con)
						table.insert(sidecons, con)
						table.insert(initConnections, con)
					end

					add(ico:GetPropertyChangedSignal('Image'):Connect(function()
						ico.Image = getIcon()
					end))
				end
			end

			local z = con.ChildAdded:Connect(h)
			table.insert(sidecons, z)
			table.insert(initConnections, z)

			for _, v in pairs(con:GetChildren()) do
				h(v)
			end
		end
	end

	if pages:FindFirstChild('SideParty') then
		h(pages.SideParty)
	end

	table.insert(initConnections, pages.ChildAdded:Connect(h))
end)

-- // Weapons UI

if not _G.selectChanged then
	task.spawn(function()
		local MAIN_UI = plr.PlayerGui:WaitForChild('MainGui').MainFrame.Equipment.Weapons.Container.List.Container

		local function handle(v)
			local b = v:FindFirstChild('Button')
			b = b and b:FindFirstChild('Icon')

			local xico = b and b:FindFirstChild('UICorner')
			local n = v.Name == 'EquipmentWeaponSlot'
			if n and b and not xico then
				local function calc()
					local ts = UTILS.SKIN_MOD.its[b.Image]
					local tog = UTILS.SKIN_INFO.skinToOg[ts] or ts
					local tocur = _G.toskin[tog]
					if tocur and tocur ~= 'Dont Change' then
						b.Image = UTILS.SKIN_MOD.viewmodels[tocur].image
					end
				end

				calc()
				b:GetPropertyChangedSignal('Image'):Connect(calc)
			elseif n and b and xico then

			end
		end

		for _, v in MAIN_UI:GetChildren() do
			handle(v)
		end

		MAIN_UI.ChildAdded:Connect(handle)
	end)
end

-- // Weapon Selection UI

if not _G.selectChanged then
	task.spawn(function()
		local function checkfor(v)
			task.spawn(function()
				local typ = v.Name == 'PickWeapons' and 1 or v.Name == 'PickWeaponsList' and 2 or 0
				if typ>0 and not v:HasTag('Econ') then
					local chosen = v:WaitForChild('ChosenWeapons')
					local list = typ == 1 and v:WaitForChild('List') or v:WaitForChild('ListContainer').List

					v:AddTag'Econ'

					local cons = {}

					if chosen and list then
						list = list.Container

						-- // LIST

						local function handle(v)
							task.spawn(function()
								local b = v.Name:find('PickWeapon') and v:WaitForChild('Button')
								if b and b:FindFirstChild('Icon') and b.Icon:FindFirstChild('Picture') then
									b = b.Icon.Picture
									b.Name = 'OPic'

									local function calc()
										local ts = UTILS.SKIN_MOD.its[b.Image]
										local tog = UTILS.SKIN_INFO.skinToOg[ts] or ts
										local tocur = _G.toskin[tog]
										if tocur and tocur ~= 'Dont Change' then
											b.Image = UTILS.SKIN_MOD.viewmodels[tocur].image
										end
									end

									calc()
									table.insert(cons, b:GetPropertyChangedSignal('Image'):Connect(calc))
								end
							end)
						end

						for _, v in pairs(list:GetChildren()) do
							handle(v)
						end

						local con = list.ChildAdded:Connect(handle)
						table.insert(cons, con)

						-- // MAIN SELECTION

						local function handle2(v)
							task.spawn(function()
								if v.Name:find('ChosenSlot') then
									local b = v.Button.Picture
									local function calc()
										local ts = UTILS.SKIN_MOD.its[b.Image]
										local tog = UTILS.SKIN_INFO.skinToOg[ts] or ts
										local tocur = _G.toskin[tog]
										if tocur and tocur ~= 'Dont Change' then
											b.Image = UTILS.SKIN_MOD.viewmodels[tocur].image
										end
									end

									calc()
									table.insert(cons, b:GetPropertyChangedSignal('Image'):Connect(calc))
								end
							end)
						end

						for _, v in pairs(chosen:GetChildren()) do
							handle2(v)
						end

						table.insert(cons, chosen.ChildAdded:Connect(handle2))

						-- // FINISH

						--for _, v in pairs(cons) do
						--	table.insert(initConnections, v)
						--end
					end
				end
			end)
		end

		local MAIN_UI = plr.PlayerGui:WaitForChild('MainGui')
		local pages = MAIN_UI.MainFrame.Pages

		if pages:FindFirstChild('PickWeapons') then
			checkfor(pages.PickWeapons)
		end

		pages.ChildAdded:Connect(checkfor)
		--table.insert(initConnections, pages.ChildAdded:Connect(checkfor))
	end)
end

_G.selectChanged = true

-- // Rest

function special(name)
	if name then 
		local keywords = {'sprint', 'idle', 'reload'}
		for _, v in keywords do
			if name:find(v) then
				return true
			end
		end
	end
end

function handlePart(v, skinName, spl, vm)
	local prim = v:FindFirstChild('Primary')
	if prim then
		local _muzzle = prim:FindFirstChild('_muzzle')
		local other = vm.ItemVisual:FindFirstChild('_muzzle', true)

		local function replaceAtt(att : Attachment)
			att = v:FindFirstChild(att, true)
			if att then
				local otherAtt = vm.ItemVisual:FindFirstChild(att.Name, true) :: Attachment
				if otherAtt then
					otherAtt.Parent = att.Parent
					otherAtt.WorldCFrame = att.WorldCFrame
					att:Destroy()
				end
			end
		end

		replaceAtt('_aim_lookat')
		replaceAtt('_aim_position')
		replaceAtt('_center')
		replaceAtt('_grip')

		if _muzzle and other then
			local p = _muzzle.Position
			_muzzle:Destroy()

			other.Position = p

			local ogk = muzzles:FindFirstChild(spl[2]) or muzzles[toMuzzle[spl[2]]]
			local muzzleClone = muzzles:FindFirstChild(skinName) or ogk
			if spl[2] ~= 'Flamethrower' then
				other:ClearAllChildren()

				for _, v in pairs((muzzleClone:FindFirstChild('Attachment') or muzzleClone):GetChildren()) do
					v:Clone().Parent = other
				end
			end

			if not other:FindFirstChildWhichIsA('Light', true) then
				for _, v in pairs(ogk:GetDescendants()) do
					if v:IsA('Light') then
						v:Clone().Parent = other
					end
				end 
			end

			other.Parent = prim
		end

		local funcs = {
			Katana = function()
				local myactive = deflectiveactive:FindFirstChild(skinName) or deflectiveactive.Default
				local myhit = deflecthit:FindFirstChild(skinName) or deflecthit.Default

				local active = vm:FindFirstChild('_katana_deflect_active', true)
				local hit = vm:FindFirstChild('_katana_deflect_hit', true)

				active:ClearAllChildren()
				hit:ClearAllChildren()

				for _, v in pairs(myactive.Attachment:GetChildren()) do
					v:Clone().Parent = active
				end

				for _, v in pairs(myhit:GetChildren()) do
					v:Clone().Parent = hit
				end
			end,
		}

		if funcs[spl[2]] then
			funcs[spl[2]]()
		end
	end
end

function applySkin(skinName, cs)
	task.spawn(function()
		if skinName == 'Dont Change' then return end
		if not UTILS.SKIN_INFO.skinToOg[skinName] then skinName = UTILS.SKIN_INFO.lowerToOg[skinName:lower()] end

		local ogitem = UTILS.SKIN_INFO.skinToOg[skinName]
		if not ogitem then return end

		local char = plr.Character
		local hum = char and char:FindFirstChild('Humanoid') :: Humanoid

		local main = plr.PlayerGui.MainGui.MainFrame
		local MAIN_UI = main.FighterInterfaces:FindFirstChild(plr.Name)

		if not hum or not MAIN_UI then return end

		for _, v in MAIN_UI.Items.Container:GetChildren() do
			if v.Name == ogitem then
				local icon = v.Icon :: ImageLabel
				icon.ResampleMode = Enum.ResamplerMode[skinName:find('Pixel') and 'Pixelated' or 'Default'] 
				icon.Image = UTILS.SKIN_MOD.viewmodels[skinName].image
			end
		end

		local function apl(vm)
			task.spawn(function()
				local skin = findSkin(skinName)
				local vm = vm or vms:GetChildren()[1]
				local root = vm and vm.PrimaryPart

				if skin and root and not vm:HasTag'Changed' then
					vm:AddTag'Changed'

					local clone = skin:Clone()

					-- // Remove Charms

					local ca = clone:FindFirstChild('_charm_attachment_model', true)
					if ca then
						ca:Destroy()
					end

					local ca = clone:FindFirstChild('_charm_pivot_attachment', true)
					if ca then
						ca:Destroy()
					end

					-- // ANIMATIONS | CLEANI

					local last = vm.Name
					local spl = string.split(vm.Name, ' - ')
					local ogWeapon = skins:FindFirstChild(spl[2], true)

					if not vm:GetAttribute('OGItem') then
						vm:SetAttribute('OGItem', spl[2])
					end

					local ig = vm:GetAttribute('OGItem')

					vm.Name = spl[1]..' - '..spl[2].. ' - '..skinName

					local itemint = plr.PlayerGui.MainGui.MainFrame.ItemInterfaces[plr.Name.. ' - '..spl[2]]

					local function set(arg1)
						local scope = itemint.Mouse.Scope
						local tbl = {
							BlurImage = scope.Blur.ImageLabel,
							CircleImage = scope.Circle.ImageLabel,
							ReticleDotUICorner = scope.Reticle.Container.Dot.UICorner,
							_dont_rotate_scope_while_sliding = false
						}

						arg1 = tbl

						-- // Rivals Scope Code [Unedited]

						if skinName == "Pixel Sniper" then
							arg1.BlurImage.Image = "rbxassetid://18171031143"
							arg1.BlurImage.ResampleMode = Enum.ResamplerMode.Pixelated
							arg1.CircleImage.Image = "rbxassetid://18171045114"
							arg1.CircleImage.ResampleMode = Enum.ResamplerMode.Pixelated
							arg1.ReticleDotUICorner:Destroy()
						else
							if skinName == "Keyper" then
								arg1.BlurImage.Image = "rbxassetid://129335242148588"
								arg1.BlurImage.Size = UDim2.new(1.25, 0, 1.25, 0)
								arg1.CircleImage.Image = "rbxassetid://81498448678518"
								arg1.CircleImage.Size = UDim2.new(1.25, 0, 1.25, 0)
								arg1._dont_rotate_scope_while_sliding = true
								return
							end
							if skinName == "Pixel Crossbow" then
								arg1.CircleImage.Image = "rbxassetid://97622703342015"
								arg1.CircleImage.ResampleMode = Enum.ResamplerMode.Pixelated
								arg1.ReticleDotUICorner:Destroy()
							end
						end
					end

					set()

					local name = vm.name

					local clean = _G.skinToAnimCon[name] or _G.skinToAnimCon[last]
					if clean then
						for _, v in pairs(clean) do
							v:Disconnect()
						end
					end

					-- // AIMING CHECK

					local vig = itemint.AimingVignette

					local last = vig.ImageTransparency
					local aiming = false

					local function aimingCallback(v)
						local funcs = {
							['AKEY-47'] = function()
								local var5 = v and .1 or 0
								UTILS.RIVALS_UTILS:CreateSound("rbxassetid://96253147006478", 0.375, 2 + var5, true, var5)
							end,
						}

						if funcs[skinName] then
							funcs[skinName]()
						end
					end

					-- // Aiming Connection

					vig:GetPropertyChangedSignal('ImageTransparency'):Connect(function()
						local _c = aiming
						if vig.ImageTransparency > last and aiming then
							aiming = false
						elseif vig.ImageTransparency < last and not aiming then
							aiming = true
						end

						if aiming ~= _c and math.abs(last-vig.ImageTransparency) < .8 then aimingCallback(aiming) end

						last = vig.ImageTransparency
					end)

					-- // ANIMATIONS TABLE

					local econAnim = vm:FindFirstChild('Anims') or Instance.new('Folder', vm)
					econAnim:ClearAllChildren()
					econAnim.Name = 'Anims'

					local animator = vm.AnimationController.Animator :: Animator

					local animtbl = {}
					local toname = {}
					local prs = {}

					local sn = _G.skinanim[name] or _G.skinanim[last]
					if sn then
						for _, v in sn do
							if v.anim then
								v.anim:Stop(0)
							end
						end
					end

					local inz = {}

					clone:PivotTo(root:GetPivot())
					for _, v in clone:GetChildren() do
						v.PrimaryPart = v:FindFirstChild('Primary')
						for _, p : BasePart in pairs(v:GetDescendants()) do
							if p:IsA('BasePart') then
								p.CanCollide = false
								p.Massless = true

								local newWeld = Instance.new('WeldConstraint', (v.PrimaryPart or v.Primary))
								newWeld.Part0 = newWeld.Parent
								newWeld.Part1 = p
							end
						end
					end

					if clone:FindFirstChild'_right_arm' then
						vm.RightArm.Massless = false

						local nw = Instance.new('Weld', vm.RightArm)
						nw.Part0 = nw.Parent
						nw.Part1 = clone._right_arm.PrimaryPart
					end

					if clone:FindFirstChild'_left_arm' then
						vm.LeftArm.Massless = false

						local nw = Instance.new('Weld', vm.LeftArm)
						nw.Part0 = nw.Parent
						nw.Part1 = clone._left_arm.PrimaryPart
					end

					for _, v in clone:GetDescendants() do
						if v:IsA('BasePart') then
							v.CanQuery = false
							v.CanTouch = false
							v.Anchored = false
							v.CastShadow = false

							if v:IsA('MeshPart') then
								v.CollisionFidelity = Enum.CollisionFidelity.Box
							end
						end
					end

					for _, v in root:GetChildren() do
						if v.Name ~= 'RightArm' and v.Name ~= 'LeftArm' then
							if v:HasTag('IsChanged') then
								v:Destroy()
							else
								v.Name = 'a'
							end
						end
					end

					local was = {}
					for _, v in vm.ItemVisual:GetChildren() do
						if v:HasTag('IsChanged') then
							table.insert(was, v)
						end
					end

					local dontDestroy = {'_katana'}

					local function destroyBlacklist(str)
						local IN_TABLE = false
						for _ , v in dontDestroy do
							if str:find(v) then
								IN_TABLE = true
							end
						end
						return IN_TABLE
					end

					for _, v : Instance in vm.ItemVisual:GetDescendants() do
						if v:IsA('MeshPart') then
							v.Size = Vector3.zero
							v.Transparency = 1
						elseif (v:IsA('ParticleEmitter') or v:IsA('RopeConstraint') or v:IsA('Beam')) and not destroyBlacklist(v.Parent.Name) then
							v:Destroy()
						end
					end

					-- // AnimationPlayed

					local apev = {}
					local playcons = {}
					function apev:Connect(func)
						table.insert(playcons, func)
					end

					-- // AnimationStopped

					local asev = {}
					local stopcons = {}
					function asev:Connect(func)
						table.insert(stopcons, func)
					end

					-- // Equiped

					local eqev = {}
					local equipcons = {}
					function eqev:Connect(func)
						table.insert(equipcons, func)
					end

					-- // Table

					local tb = {
						ItemModel = clone,
						_destroyed = false,
						AnimationPlayed = apev,
						AnimationStopped = asev,
						Equipped = eqev,
					}

					function tb:_RegisterAmmoVisual()

					end

					local playii = {}
					function tb:IsAnimationPlaying(n)
						return table.find(playii, n)
					end

					-- // ExtraFuncs

					local ef = UTILS.EXTRA_FUNCS[skinName] and loadstring(UTILS.EXTRA_FUNCS[skinName])()
					if ef then
						ef = ef.new(tb)
					end

					-- // Rest

					local tovis = {}

					for _, v in clone:GetChildren() do
						if v:FindFirstChild'Primary' then
							handlePart(v, skinName, spl, vm)

							v:AddTag'IsChanged'

							local newMotor = Instance.new('Motor6D')
							newMotor.Name = `ItemVisual["{v.Name}"]`
							newMotor.Part0 = root
							newMotor.Part1 = v.Primary
							newMotor:AddTag'IsChanged'
							newMotor.Parent = root

							local prim = v.Primary
							prim.Name = `{v.Name}Primary`

							newMotor.C0 = v:GetAttribute('C0') or CFrame.new()
							newMotor.C1 = v:GetAttribute('C1') or CFrame.new()

							v.Parent = vm.ItemVisual
							table.insert(tovis, v)
						end
					end

					for _, v in pairs(was) do
						v:Destroy()
					end

					clone:Destroy()

					-- // ANIMATIONS

					local _precontr = {
						anims = {}
					}

					function _precontr:add(pre, b)
						local x = {tbl = b}

						function x:stop()
							b.anim:Stop()
						end

						function x:play(args)
							args = args or {}

							local ref = args.reference :: AnimationTrack
							if ref and not ref.IsPlaying then return end

							if not special(b.name) and not args.isSpecial then
								for _, v : AnimationTrack in pairs(animator:GetPlayingAnimationTracks()) do
									if table.find(_G.ourAnims, v) and not special(toname[v.Animation.AnimationId]) then
										v:Stop()
									end
								end
							end

							local loaded = b.anim
							loaded.Priority = args.priority or prs[loaded] or Enum.AnimationPriority.Action2
							loaded.TimePosition = args.pos or 0			
							loaded:Play()
							loaded:AdjustWeight(1)
							loaded:AdjustSpeed(b.relinfo.Speed)

							-- // Connections

							task.spawn(function()
								local basicPlayed = ANIM_TO_NAME[b.prename] or b.prename

								table.insert(playii, basicPlayed)

								for _, v in playcons do
									v(basicPlayed)
								end

								table.insert(initConnections, loaded.Stopped:Once(function()
									table.remove(playii, table.find(playii, basicPlayed))
									for _, v in stopcons do
										v(basicPlayed)
									end
								end))
							end)

							-- // Rest

							local norm = loaded.Speed
							prs[loaded] = loaded.Priority

							-- // SOUNDS

							if b then
								if args.silenceReference and ref then
									table.insert(_G.silenced, ref)
								end

								if b.soundcall then
									task.spawn(b.soundcall,UTILS.RIVALS_UTILS, b.name, loaded.Speed, loaded, vm)
								end

								-- // REST

								if ref then
									table.insert(_G.skinToAnimCon[name], ref.Stopped:Once(function()
										if args.unsilenceAfter then
											table.remove(_G.silenced, table.find(_G.silenced, ref))
										end

										loaded:Stop()
									end))
								end

								local function upd()
									local no = {'Water', 'Air'}
									if b.name:find'sprint' then
										loaded:AdjustSpeed(table.find(no, hum.FloorMaterial.Name) and .15 or norm)
									end
								end

								if args.stopref and ref then
									ref.Priority = Enum.AnimationPriority.Core
									ref:AdjustSpeed(0)
									ref:AdjustWeight(.001, 0)
								end

								if b.name:find'sprint' then
									local con = hum:GetPropertyChangedSignal('FloorMaterial'):Connect(upd)
									upd()

									table.insert(_G.skinToAnimCon[name], con)

									loaded.Stopped:Once(function()
										con:Disconnect()
									end)
								end
							end
						end

						_precontr.anims[pre] = x
					end

					-- // REST

					local _ogidtoinf = {}
					local _ogprentoid = {}

					for prename, name in UTILS.SKIN_MOD.viewmodels[ig].anims do
						local vmi = UTILS.SKIN_MOD.viewmodels[ig]

						local id = _G.animLib.Info[name].AnimationID
						local animType = vmi.animsReverse[name]

						_ogprentoid[prename] = id

						_ogidtoinf[id] = {
							name = name,
							prename = prename,
						}

						local new = UTILS.SKIN_MOD.viewmodels[skinName]
						local typeToReal = new.anims[animType]

						local nowid = _G.animLib.Info[typeToReal]

						if nowid then
							table.insert(inz, prename)
							
							local SOUND_CODE = UTILS.SKIN_SOUND_CODE[typeToReal]
							local SOUND_MOD = SOUND_CODE and loadstring(SOUND_CODE)
							
							local LOADED_ANIM = Instance.new('Animation') :: AnimationTrack
							LOADED_ANIM.AnimationId = nowid.AnimationID
							LOADED_ANIM.Parent = econAnim
							LOADED_ANIM = animator:LoadAnimation(LOADED_ANIM)

							table.insert(_G.ourAnims, LOADED_ANIM)

							toname[nowid.AnimationID] = name

							animtbl[id] = {
								anim = LOADED_ANIM,
								name = typeToReal,
								prename = prename,
								type = animType,
								relinfo = nowid,
								soundcall = SOUND_MOD and SOUND_MOD()
							}

							_precontr:add(prename, animtbl[id])
						end
					end

					for prename, name in UTILS.SKIN_MOD.viewmodels[skinName].anims do
						if not table.find(inz, prename) then
							local nowid = _G.animLib.Info[name]

							if nowid.AnimationID then
								local SOUND_CODE = UTILS.SKIN_SOUND_CODE[name]
								local SOUND_MOD = SOUND_CODE and loadstring(SOUND_CODE)

								local LOADED_ANIM = Instance.new('Animation') :: AnimationTrack
								LOADED_ANIM.AnimationId = nowid.AnimationID
								LOADED_ANIM.Parent = econAnim
								LOADED_ANIM = animator:LoadAnimation(LOADED_ANIM)

								table.insert(_G.ourAnims, LOADED_ANIM)

								toname[nowid.AnimationID] = name

								_precontr:add(prename, {
									anim = LOADED_ANIM,
									name = prename,
									prename = prename,
									type = prename,
									relinfo = nowid,
									soundcall = SOUND_MOD and SOUND_MOD()
								})
							end
						end
					end

					_G.topre[vm] = _precontr.anims

					-- // Knife Backstab

					local h = _precontr.anims.HeavyAttackAnimationHit
					if h then
						table.insert(_G.headshotFuncs, function()
							if vms:GetChildren()[1] == vm then
								h:play({
									reference = _precontr.anims.HeavyAttack1.tbl.anim,
									isSpecial = 1,
									silenceReference = 1,
									unsilenceAfter = 1,
								})
							end
						end)
					end

					-- // Rest

					local playing = {}

					local function ct(track : AnimationTrack)
						if not table.find(_G.ourAnims, track) then
							local pr = track.Priority
							track:AdjustWeight(0.0001, 0)
							track:AdjustSpeed(0)
							track.Priority = Enum.AnimationPriority.Core

							local bg = _ogidtoinf[track.Animation.AnimationId]
							local b = animtbl[track.Animation.AnimationId]

							local z

							if bg and bg.prename == 'rareinspect' then
								z = _precontr.anims.inspect
							end

							local ri = _precontr.anims.rareinspect
							local inspects = {'inspect', 'rareinspect'}
							local rare = false
							if ri and math.random(1, (_G.rarechance or 6)) == 1 and table.find(inspects, bg.prename) then
								z = _precontr.anims.inspect
								rare = true

								local s = 1 + 0.25 * math.random()
								UTILS.RIVALS_UTILS:CreateSound('rbxassetid://13159969353', .25, s, nil, true)
							end

							if b or z then
								local z = z or _precontr.anims[b.prename]
								if z then
									local basicPlayed = z.tbl.prename
									local basic = z.tbl.anim

									local tbl = {
										pos = track.TimePosition,
										priority = prs[z.tbl.anim] or pr,
										reference = track
									}

									z:play(tbl)

									if ri and rare then
										basicPlayed = 'rareinspect'
										basic = ri.tbl.anim

										ri:play({
											reference = _precontr.anims.inspect.tbl.anim,
											isSpecial = 1,
											silenceReference = 1,
											unsilenceAfter = 1,
											stopref = 1,
										})
									end
								end
							end
						end
					end

					table.insert(_G.applied, vm)

					local function pt(p)
						local c = vms:GetChildren()[1]

						if p ~= vms then
							for _, v in weaponSounds:GetChildren() do
								if (not v:GetAttribute('DontClearSound') and _G.soundToWeapon[v] == vm) then
									v:Destroy()
								end
							end
						end

						if not c or c == vm or not table.find(_G.applied, c) then
							soundOn = p ~= vms
							soundGroup.Volume = soundOn and ss.Other.Volume or 0

							for _, v in equipcons do
								v()
							end

							if soundOn then
								for _, v in animtbl do
									v.anim:Stop()
								end
							end
						end
					end

					_G.skinanim[name] = animtbl
					_G.skinToAnimCon[name] = {}
					_G.skinToAnimCon[name][1] = animator.AnimationPlayed:Connect(ct)
					for _, v in animator:GetPlayingAnimationTracks() do
						ct(v)
					end

					_G.skinToAnimCon[name][3] = vm:GetPropertyChangedSignal('Parent'):Connect(function()
						if not vm.Parent then
							tb._destroyed = true
						end

						pt(vm.Parent)
					end)

					pt(vm.Parent)

					-- // REMOVING

					_G.skinToAnimCon[name][2] = vm:GetPropertyChangedSignal('Parent'):Once(function()
						if not vm.Parent then
							pt()
							for _, v in _G.skinToAnimCon[name] do
								v:Disconnect()
							end
							_G.skinToAnimCon[name] = nil
						end
					end)

					-- // ADD

					if vm == vms:GetChildren()[1] and _G.frr then
						_G.frr()
					end

					for _, v in tovis do
						v.Parent = vm.ItemVisual
					end
				end
			end)
		end

		local first = vms:GetChildren()[1]
		local z = first and first.Name:split' - '
		if first and z[1] == plr.Name and z[2] == ogitem then
			apl(first)
		end

		for _, v in game:GetService('ReplicatedStorage').Assets.Temp.ViewModels:GetChildren() do
			local z = v.Name:split' - '
			if v and z[1] == plr.Name and z[2] == ogitem then
				apl(v)
			end
		end
	end)
end

-- // Skinchanger Save

readsfile()
READ_FILE = true

-- // Rest

cchar()
table.insert(initConnections, plr.CharacterAdded:Connect(cchar))
_G.ac = applySkin

queue_on_teleport(game:HttpGet(URL_ROOT..'MainSkin'))

return module
