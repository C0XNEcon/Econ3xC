local module = {
	canPlay = {
		'rbxassetid://13158735106', 
		'rbxassetid://13158734943', 
		'rbxassetid://13158735037',
		--'rbxassetid://13159969353'
	},

	headshotid = 'rbxassetid://16537337310',
	bodyshotid = 'rbxassetid://13110130082'
}

--[[

ADDING NEW SKINS:

- Copying rivals ItemLibrary to WeaponTypes 'str'
- Run Clipboard script and pasting to Github
- Put new add_animations from AnimLib to Github
- Put add_viewmodel from CosmeticLibrary to Github

ADDING NEW ITEMS:

- Primary, Secondary, Melee, Utility from ItemLib to WeaponTypes 'str'

]]

local plr = game:GetService('Players').LocalPlayer

local run = game:GetService('RunService')
local ss = game:GetService('SoundService')
local uis = game:GetService('CoreGui')
local rep = game:GetService('ReplicatedStorage')

local scripts = plr.PlayerScripts

scripts:WaitForChild('Assets')

local misc = scripts.Assets.Misc
local skins = scripts.Assets.ViewModels
local vms = game:GetService'Workspace'.ViewModels.FirstPerson

local muzzles = misc.MuzzleFlashes
local deflectiveactive = misc.DeflectActiveEffects
local deflecthit = misc.DeflectHitEffects

local weaponSounds = scripts.Modules.ClientReplicatedClasses.ClientFighter.ClientItem
local hitmarkerSounds = weaponSounds.ClientViewModel

local load = false
local load2 = false
local load3 = false
local load4 = false
local load5 = false
local load6 = false

local updatedCharFuncs = {}

_G.lt = tick()

-- // Loading

if _G.hd then
	_G.hd:Disconnect()
end

_G.headshotFuncs = {}

_G.hd = hitmarkerSounds.ChildAdded:Connect(function(v : Sound)
	if v:IsA('Sound') and v.SoundId == module.headshotid then
		for _, v in pairs(_G.headshotFuncs) do
			v()
		end
	end
end)

local skinmodx = not load and _G.skinmod
if not skinmodx then
	task.spawn(function()
		skinmodx = loadstring(game:HttpGet('https://raw.githubusercontent.com/C0XNEcon/Econ3xC/refs/heads/main/Skin'))()
	end)
end

local utility = not load2 and _G.utility
if not utility then
	task.spawn(function()
		utility = loadstring(game:HttpGet('https://raw.githubusercontent.com/C0XNEcon/Econ3xC/refs/heads/main/UtilityFake'))()
	end)
end

local skinfo = not load3 and _G.skinfo
if not skinfo then
	task.spawn(function()
		skinfo = loadstring(game:HttpGet('https://raw.githubusercontent.com/C0XNEcon/Econ3xC/refs/heads/main/SkinInfo'))()
	end)
end

local bakedSoundInfo = not load4 and _G.bakeds
if not bakedSoundInfo then
	task.spawn(function()
		bakedSoundInfo = loadstring(game:HttpGet('https://raw.githubusercontent.com/C0XNEcon/Econ3xC/refs/heads/main/AnimSound'))()
	end)
end

local weapontypes = not load5 and _G.wpt
if not weapontypes then
	task.spawn(function()
		weapontypes = loadstring(game:HttpGet('https://raw.githubusercontent.com/C0XNEcon/Econ3xC/refs/heads/main/WeaponTypes'))()
	end)
end

local extrafunc = not load6 and _G.exf
if not extrafunc then
	task.spawn(function()
		extrafunc = loadstring(game:HttpGet('https://raw.githubusercontent.com/C0XNEcon/Econ3xC/refs/heads/main/ExtraFunc'))()
	end)
end

repeat run.Stepped:Wait() until skinmodx and utility and skinfo and bakedSoundInfo and weapontypes and extrafunc

local sound = Instance.new('Sound')
sound.Volume = 1
sound.SoundId = 'rbxassetid://6895079853'

local function playSound(sp, rep, vol)
	local new = (rep or sound):Clone()
	new.Parent = workspace
	new.Volume = vol or 1
	new.PlaybackSpeed = sp or 1
	new:Play()

	new.Ended:Connect(function()
		new:Destroy()
	end)
end

playSound()

-- // Rest

local icoToSikn = skinmodx.its

local z = 'https://raw.githubusercontent.com/C0XNEcon/Econ3xC/refs/heads/main/'
local ui = loadstring(game:HttpGet(z..'Econ%20UI.txt'))()
local uiii = ui

local Window = ui:CreateWindow({
	Name = 'Econ Skinchanger',
	Icon = nil,
	LoadingTitle = '',
	LoadingSubtitle = "by ConePartyy",
	Theme = "AmberGlow", 

	DisableEconFieldPrompts = true,
	DisableBuildWarnings = true,

	ConfigurationSaving = {
		Enabled = true,
		FolderName = 'cone',
		FileName = "econ"
	},

	Discord = {
		Enabled = false,
		Invite = "acv8tdb8",
		RememberJoins = true
	},

	KeySystem = false,
	KeySettings = {
		Title = 'Econ | Password',
		Subtitle = '',
		Note = nil,
		FileName = 'econK',
		SaveKey = true,
		GrabKeyFromSite = true,
		Key = {}
	}
})

-- // WRAP CHANGER CONTROL

local wrapSkinInfo = {}

local wrapper = loadstring(game:HttpGet(z..'Wrapper.txt'))()

function readSkinFile()
	local rf = isfile('cSkin') 
	if rf then
		local splits = string.split(readfile('cSkin'), '.')
		for _, v in pairs(splits) do
			local inf = string.split(v, '`')
			wrapSkinInfo[inf[1]] = {
				wrap = inf[2],
				inverted = inf[3] == 'true'
			}
		end
	else
		writefile('cSkin', '')
	end
end

function writeSkinFile()
	local str = ''
	for skin, inf in pairs(wrapSkinInfo) do
		str..=skin..'`'..(inf.wrap or 'None')..'`'..tostring(inf.inverted)..'.'
	end
	writefile('cSkin', str)
end

readSkinFile()

-- // Skinchanger Filing

local weaponToButton = {}
local charapb = {}

local cid = plr.UserId

function readsfile()
	local rf = isfile('cSkinchanged') 
	if rf then
		local splits = string.split(readfile('cSkinchanged'), '.')
		for _, v in pairs(splits) do
			local inf = string.split(v, '`')
			if weaponToButton[inf[1]] then
				_G.toskin[inf[1]] = inf[2]
				weaponToButton[inf[1]]:Set({inf[2]}, true)
			elseif tonumber(inf[1]) and not inf[2] then
				cid = tonumber(inf[1])
				charapb:Set(cid)
			end
		end
	else
		writefile('cSkinchanged', '')
	end
end

function writesfile()
	local str = tostring(cid)..'.'
	for weapon, skin in pairs(_G.toskin) do
		str..=weapon..'`'..skin..'.'
	end
	writefile('cSkinchanged', str)
end

-- // Rest

local ps = plr.PlayerScripts:WaitForChild('Assets')

local function gt()
	local inf = wrapSkinInfo[string.split(cw.Name, ' - ')[3]]
	wrapper:wrapThis(cw, (inf and inf.wrap or 'None'), (inf and inf.inverted), ps.ViewModels, ps.WrapTextures)
end

local function check(v)
	if string.find(v.Name, plr.Name) then
		local rest = string.split(v.Name, ' - ')

		cw = v
		gt()
	end
end

if vms:GetChildren()[1] then
	check(vms:GetChildren()[1])
end

-- // REST

local to = {
	'Primary', 'Secondary', 'Melee', 'Utility'
}

local toskin = {}
_G.toskin = toskin

local initConnections = {}

-- // CHARACTER CHANGER

local p = game:GetService('Players')

local loadedids = {}

if not _G.ourrrs then
	_G.ourrrs = {}
end

local ltagcon = nil
local lll = nil

-- // dn = DisplayName [] usn = Username

local dn = (plr.DisplayName or plr.Name)..(plr.HasVerifiedBadge and ' '..utf8.char(0xE000) or '')
local usn = plr.Name

-- // cchar

local function cchar(id)
	task.spawn(function()
		local id = typeof(id) == 'number' and id or cid
		if not id then return end

		local lid = loadedids[id]

		local suc, z = false, 'Lid Exists'
		if not (lid and lid.apr) then
			suc, z = pcall(function()
				return p:GetCharacterAppearanceAsync(id)
			end)
		end

		local cha = lid and lid.apr or suc and z

		if not cha then ui:Notify({Title = 'CharacterAppearance Error', Content = tostring(z), Duration = 10, Image = 'search-x'}) return end

		local char = plr.Character

		-- // REST

		local inff = nil
		task.spawn(function()
			-- // VISUALS

			for _, v in pairs(updatedCharFuncs) do
				v()
			end

			local suc, z = false, 'Lid Exists'
			if not (lid and (not lid.inff)) then
				suc, z = pcall(function()
					return game:GetService('UserService'):GetUserInfosByUserIdsAsync({id})
				end)
			end

			local inf = lid and lid.inff or suc and z

			if not inf or typeof(inf) == 'boolean' then ui:Notify({Title = 'Name,Displayname Error', Content = tostring(z), Duration = 10, Image = 'search-x'}) return end

			if not inf or typeof(inf) == 'boolean' then
				inf = {
					{
						HasVerifiedBadge = false,
						Username = 'HTTP_429',
						DisplayName = 'error429'
					},
					isfake = true
				}
			end

			inff = inf
			loadedids[id].inff = inf

			if ltagcon then
				for _, v in pairs(ltagcon) do
					v:Disconnect()
				end
			end

			if lll then
				lll:Disconnect()
			end

			if inf and inf[1] then
				inf = inf[1]

				local root = char:WaitForChild('HumanoidRootPart')

				local function tagfunc(tag)
					if not tag or tag.Name ~= 'Nametag' then return end

					if ltagcon then
						for _, v in pairs(ltagcon) do
							v:Disconnect()
						end
					end

					local frame = tag.Frame or tag:WaitForChild('Frame')
					local ff = frame.Player
					local un = ff.Username

					local function hn()
						dn = (tostring(inf.DisplayName) or inf.Username)..(inf.HasVerifiedBadge and ' '..utf8.char(0xE000) or '')
						usn = inf.Username
						ff.Text = dn
						un.Text = inf.DisplayName and '@'..inf.Username or ''
					end

					hn()

					ltagcon = {}

					table.insert(ltagcon, ff:GetPropertyChangedSignal('Text'):Connect(hn))
					table.insert(ltagcon, tag:GetPropertyChangedSignal('Parent'):Once(function()
						for _, v in pairs(ltagcon) do
							v:Disconnect()
						end
					end))

					for _, v in pairs(ltagcon) do
						table.insert(initConnections, v)
					end
				end

				tagfunc(root:FindFirstChild('Nametag'))
				lll = root.ChildAdded:Connect(tagfunc)
				table.insert(initConnections, lll)
			end
		end)

		loadedids[id] = {
			apr = cha,
		}

		task.spawn(function()
			local suc, z = false, 'Lid Exists'
			if not (lid and lid.ap) then
				suc, z = pcall(function()
					return p:GetHumanoidDescriptionFromUserId(id)
				end)
			end

			local ap = lid and lid.ap or suc and z

			if not ap then ui:Notify({Title = 'FaceDecal Error', Content = tostring(z), Duration = 10, Image = 'search-x'}) return end

			if not ap then
				ap = {
					Face = 0
				}
			end

			loadedids[id].ap = ap

			local face = ap.Face
			local faceid = "rbxthumb://type=Asset&w=768&h=432&id="..face

			local head = char:WaitForChild('Head')
			for _, v in pairs(head:GetChildren()) do
				if v.Name == 'face' then
					v:Destroy()
				end
			end

			local newface = Instance.new('Decal', head)
			newface.Name = 'face'
			newface.Texture = face ~= 0 and faceid or 'rbxasset://textures/face.png'
		end)

		local function caa(characterModel, accessory)
			task.spawn(function()
				local accessoryAttachment = accessory:FindFirstChildWhichIsA("Attachment", true)
				if not accessoryAttachment then
					warn("No attachments found in accessory. Accessory was not attached.")
					return
				end

				local attachmentName = accessoryAttachment.Name
				local attachTo = nil

				local st = tick()
				repeat run.Stepped:Wait() attachTo = characterModel:FindFirstChild(attachmentName, true) until attachTo

				if not attachTo or not attachTo:IsA("Attachment") then
					warn(string.format("No attachment named %s found in character. Accessory was not attached.", attachmentName))
					return
				end

				local Handle = accessory:FindFirstChild("Handle")
				if not Handle then
					warn("Attachment has no handle. Accessory was not attached.")
					return
				end

				Handle.CFrame = attachTo.WorldCFrame * accessoryAttachment.CFrame:Inverse()

				local nc = Instance.new('WeldConstraint', Handle)
				nc.Part0 = Handle
				nc.Part1 = attachTo.Parent

				accessory.Parent = characterModel
			end)
		end

		local names = {'Shirt', 'Pants', 'ShirtGraphic', 'Accessory'}

		local function hand(v)
			if table.find(names, v.ClassName) then
				task.defer(function()
					v:Destroy()
				end)
			elseif v.ClassName == 'BodyColors' then
				local bc = cha:FindFirstChild('Body Colors') :: BodyColors
				if bc then
					v.HeadColor3 = bc.HeadColor3
					v.TorsoColor3 = bc.TorsoColor3
					v.LeftArmColor3 = bc.LeftArmColor3
					v.LeftLegColor3 = bc.LeftLegColor3
					v.RightArmColor3 = bc.RightArmColor3
					v.RightLegColor3 = bc.RightLegColor3

					local to = {
						RightUpperArm = bc.RightArmColor3,
						RightLowerArm = bc.RightArmColor3,
						RightHand = bc.RightArmColor3,

						LeftUpperArm = bc.LeftArmColor3,
						LeftLowerArm = bc.LeftArmColor3,
						LeftHand = bc.LeftArmColor3,

						Head = bc.HeadColor3,
						UpperTorso = bc.TorsoColor3,
						LowerTorso = bc.TorsoColor3,

						RightUpperLeg = bc.RightLegColor3,
						RightLowerLeg = bc.RightLegColor3,
						RightFoot = bc.RightLegColor3,

						LeftUpperLeg = bc.LeftLegColor3,
						LeftLowerLeg = bc.LeftLegColor3,
						LeftFoot = bc.LeftLegColor3,
					}

					for piece, colr in pairs(to) do
						task.spawn(function()
							char:WaitForChild(piece).Color = colr
						end)
					end
				end
			end
		end

		for _, v : BodyColors in pairs(char:GetChildren()) do
			hand(v)
		end

		local con2
		local con = char.ChildAdded:Connect(function(v)
			if not table.find(_G.ourrrs, v) then
				hand(v)
			end
		end)

		table.insert(initConnections, con)
		table.insert(initConnections, char:GetPropertyChangedSignal('Parent'):Once(function()
			if con then
				con:Disconnect()
			end

			if con2 then
				con2:Disconnect()
			end
		end))

		local function h2(v)
			if table.find(names, v.ClassName) then
				if v:IsA('Accessory') then
					local v = v:Clone()
					for _, v in pairs(v:GetChildren()) do
						if v:IsA('BasePart') then
							v.CanCollide = false
							v.CanQuery = false
							v.CanTouch = false
							v.CollisionGroup = 'Players'
							v.Massless = true
						end
					end

					table.insert(_G.ourrrs, v)
					caa(char, v)
				else 
					local cl = v:Clone() :: BodyColors
					table.insert(_G.ourrrs, cl)
					cl.Parent = char
				end
			end
		end

		for _, v in pairs(cha:GetChildren()) do
			h2(v)
		end

		con2 = cha.ChildAdded:Connect(h2)
		table.insert(initConnections, con2)
	end)
end

-- // REST

if not _G.nametoid then
	_G.nametoid = {}
end

local redfile = false

for t, weapons in pairs(weapontypes.typeToWeapons) do
	local gameplayTab = Window:CreateTab(to[t], nil)

	if t == 1 then
		local sec = gameplayTab:CreateSection('Character Changer')

		local charchanger = gameplayTab:CreateInput({
			Name = 'Player ID / Name',
			CurrentValue = tostring(cid),
			PlaceholderText = 'ConePartyy',
			RemoveTextAfterFocusLost = false,
			Flag = 'appearancechangerid',
			Callback = function(t)
				local suc, z = false, 'Lid Exists'
				if not (tonumber(t) or tonumber(_G.nametoid[t])) then
					suc, z = pcall(function()
						return p:GetUserIdFromNameAsync(t)
					end)
				end

				local id = tonumber(t) or tonumber(_G.nametoid[t] or suc and z)

				if not id then ui:Notify({Title = 'Name>ID Error', Content = tostring(z), Duration = 10, Image = 'search-x'}) return end

				if id then
					_G.nametoid[t] = id
					cid = id
					cchar(id)

					if redfile then
						writesfile()
					end
				end
			end,
		})

		charapb = charchanger

		local visualSection = gameplayTab:CreateSection('Wrap Changer - Hold a weapon')

		local selectedWrap = 'None'
		local selectedWeapon = 'Assault Rifle'
		local wrapsX = {'None'}
		local inverted = false

		for wrap, v in pairs(wrapper:getAll()) do
			table.insert(wrapsX, wrap)
		end

		function updateSkin()
			local name = string.split(cw.Name, ' - ')[3]
			wrapSkinInfo[name] = {
				wrap = selectedWrap,
				inverted = inverted,
			}

			writeSkinFile()

			gt()
		end

		local typeWrap
		local wrapDropdown = gameplayTab:CreateDropdown({
			Name = 'Wrap',
			Options = wrapsX,
			CurrentOption = {selectedWrap},
			MultipleOptions = false,
			Ext = true,
			Flag = 'wcwcdropdown',
			Callback = function(Options, nosound)
				selectedWrap = Options[1]

				if not nosound and not (not vms or #vms:GetChildren() == 0) then
					updateSkin()
				elseif not nosound then
					ui:Notify({
						Title = 'Error',
						Content = 'Hold a weapon to change your wrap', 
						Image = 6026568210,
						Duration = 2,
					})
				end
			end,
		})

		local wrapz = {'none'}
		for wrap, v in pairs(wrapper:getAll()) do
			table.insert(wrapz, string.lower(wrap))
		end

		typeWrap = gameplayTab:CreateInput({
			Name = 'Type Wrap',
			CurrentValue = selectedWrap,
			PlaceholderText = selectedWrap,
			RemoveTextAfterFocusLost = true,
			Ext = true,
			Flag = 'wcwcinput',
			Callback = function(Text, nosound)
				if table.find(wrapz, string.lower(Text)) then
					local realWrap = 'None'
					for w, v in pairs(wrapper:getAll()) do
						if string.lower(w) == string.lower(Text) then
							realWrap = w
						end
					end

					if not (not vms or #vms:GetChildren() == 0) then
						wrapDropdown:Set({realWrap}, nosound)
					end

					selectedWrap = realWrap

					if not nosound and not (not vms or #vms:GetChildren() == 0) then
					elseif not nosound then
						ui:Notify({
							Title = 'Error',
							Content = 'Hold a weapon to change your wrap', 
							Image = 6026568210,
							Duration = 2,
						})
					end
				end
			end,
		})

		local invertedToggle = gameplayTab:CreateToggle({
			Name = 'Inverted',
			CurrentValue = false,
			Ext = true,
			Flag = "invtoggle",
			Callback = function(Value, nosound)
				inverted = Value

				if not nosound and not (not vms or #vms:GetChildren() == 0) then
					updateSkin()
				elseif not nosound then
					ui:Notify({
						Title = 'Error',
						Content = 'Hold a weapon to change your wrap', 
						Image = 6026568210,
						Duration = 2,
					})
				end
			end,
		})

		table.insert(initConnections, vms.ChildAdded:Connect(function(v)
			check(v)

			if not v:HasTag('Changed') then
				for _, v in pairs(_G.toskin) do
					_G.ac(v)
				end
			end

			local n = string.split(cw.Name, ' - ')[3]
			local inf = wrapSkinInfo[n]
			visualSection:Set(n and 'Wrap Changer - '..n or 'Wrap Changer - Hold a weapon')
			task.spawn(function()
				typeWrap:Set(inf and inf.wrap or 'None', 1)
			end)

			task.spawn(function()
				invertedToggle:Set(inf and inf.inverted, 1)	
			end)
		end))

		table.insert(initConnections, vms.ChildRemoved:Connect(function(v)
			if not vms or #vms:GetChildren() == 0 then
				visualSection:Set('Wrap Changer - Hold a weapon')
				task.spawn(function()
					typeWrap:Set('None', 1)
				end)

				task.spawn(function()
					invertedToggle:Set(false, 1)	
				end)
			end
		end))

		local function frcheck()
			local v = vms:GetChildren()[1]
			if v then
				check(v)

				local n = string.split(cw.Name, ' - ')[3]
				local inf = wrapSkinInfo[n]
				visualSection:Set(n and 'Wrap Changer - '..n or 'Wrap Changer - Hold a weapon')
				task.spawn(function()
					typeWrap:Set(inf and inf.wrap or 'None', 1)
				end)

				task.spawn(function()
					invertedToggle:Set(inf and inf.inverted, 1)	
				end)
			end
		end

		_G.frr = frcheck
	end

	local visualSection = gameplayTab:CreateSection('Weapons')

	for skin, v in pairs(weapons) do
		skin = v
		v = skinfo.skinInfo[v]

		if v then
			local ov = table.clone(v)
			v = {'Dont Change'}
			for _, v2 in pairs(ov) do
				table.insert(v, v2)
			end

			local selectedSkin = [[Dont Change]]
			local drop = gameplayTab:CreateDropdown({
				Name = skin,
				Options = v,
				CurrentOption = {[[Dont Change]]},
				MultipleOptions = false,
				--Ext = true,
				Flag = skin,
				Callback = function(Options, nosound, nowrite)
					selectedSkin = Options[1]

					_G.toskin[skin] = Options[1]

					if not nosound then
						_G.ac(selectedSkin)
						if redfile then
							writesfile()
						end
					end
				end,
			})

			weaponToButton[skin] = drop
		end
	end
end

local going = true

if plr:GetAttribute('OriginalPositionb') then 
	plr:SetAttribute('OriginalPositionb', nil)		
end

plr:SetAttribute('OriginalPositionb', true)

table.insert(initConnections, plr:GetAttributeChangedSignal('OriginalPositionb'):Connect(function()
	for _, v in pairs(initConnections) do
		v:Disconnect()
	end

	going = false
	return
end))

local relAnim = rep.Modules.AnimationLibrary

local soundGroup = ss:FindFirstChild('Zero') or Instance.new('SoundGroup', ss)
soundGroup.Name = 'Zero'

local animStorage = uis:FindFirstChild('AnimsEcon') or Instance.new('Folder', uis)
animStorage.Name = 'AnimsEcon'

local soundOn = true

if _G.soundCon then
	_G.soundCon:Disconnect()
end

if _G.volumeC then
	_G.volumeC:Disconnect()
end

if not _G.skinanim then
	_G.skinanim = {}
end

if not _G.applied then
	_G.applied = {}
end

_G.volumeC = ss.Other:GetPropertyChangedSignal('Volume'):Connect(function()
	if soundOn then
		soundGroup.Volume = ss.Other.Volume
	end
end)

_G.soundCon = weaponSounds.ChildAdded:Connect(function(s)
	if (not table.find(module.canPlay, s.SoundId) or s.PlaybackSpeed == .5) and not s:HasTag('IsOurs') then
		s.SoundGroup = soundGroup
	end
end)

_G.wpt = weapontypes
_G.skinfo = skinfo
_G.skinmod = skinmodx
_G.utility = utility
_G.exf = extrafunc

local toMuzzle = {
	Minigun = 'Minigun',
	Spray = 'Spray',
}

for _, v in pairs(skins.Weapons:GetChildren()) do
	if not toMuzzle[v.Name] then
		toMuzzle[v.Name] = 'Default'
	end
end

if not _G.ourAnims then
	_G.ourAnims = {}
end

if not _G.skinToAnimCon then
	_G.skinToAnimCon = {}
end

task.spawn(function()
	local prelo = {}
	for _, v in pairs(_G.toskin) do
		table.insert(prelo, skinmodx.viewmodels[v].image)
	end
	game:GetService('ContentProvider'):PreloadAsync(prelo)
end)

--ui.LoadConfiguration()

-- // EquipmentScene Weapons Changer

function findSkin(name)
	for _, v in pairs(skins:GetChildren()) do
		for _, v in pairs(v:GetChildren()) do
			if v.Name == name then return v end
		end
	end
end

--if not _G.selectChanged then
--	local function handle(v)
--		if v.Name == 'SDSDSD' then return end
--		local vw = findSkin(v.Name)
--		if not vw then return end

--		local vpos = v:IsA('Model') and v:GetPivot().Position
--		local indist = v:IsA('Model') and (vpos-vw:GetPivot().Position).Magnitude < 1
--		--local ec = workspace:FindFirstChild('EquipmentScene')

--		if indist then
--			local tog = skinfo.skinToOg[v.Name] or v.Name
--		    local tocur = toskin[tog]

--			if tocur and tocur ~= 'Dont Change' then
--				v:ClearAllChildren()

--				local skin = findSkin(tocur):Clone()
--				skin:PivotTo(v:GetPivot())
--				skin.Parent = v
--			end
--		end
--	end

--	_G.h = handle

--	for _, v in pairs(workspace:GetChildren()) do
--		_G.h(v)
--	end

--	workspace.ChildAdded:Connect(function(v)
--		_G.h(v)
--	end)
--end

-- // Weapons ViewProfile UI Changer

local prcons = {}
local pacons = {}
local pa2cons = {}
local sidecons = {}

local is = _G.selectChanged and true or false

if not _G.saved then
	_G.saved = {}
end

function getIcon()
	local content = nil
	local isReady = nil
	local id = cid or plr.UserId
	local s = _G.saved[id]

	if s then
		content = s.content
		isReady = s.isReady
	else
		local suc, c, r = pcall(function()
			return game:GetService('Players'):GetUserThumbnailAsync(id, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420)
		end)

		if not suc or not r then ui:Notify({Title = 'PlrIcon Error', Content = tostring(c), Duration = 10, Image = 'search-x'}) return end

		content = c
		r = r

		_G.saved[id] = {
			content = c, isReady = r
		}
	end

	return content, isReady
end

if not _G.at then
	_G.at = {}
end

if not _G.is then
	_G.is = {}
end

if not _G.ogim then
	_G.ogim = {}
end

-- // FUNCTIONS

if not _G.inf then
	_G.inf = {
		idtoname = {}
	}
end

function idtplr(id)
	local d = _G.inf.idtoname[id]
	if d then return d end

	for _, v in pairs(game:GetService('Players'):GetPlayers()) do
		if v.UserId == id then
			_G.inf.idtoname[id] = v
			return v
		end
	end
end

-- // REST

task.spawn(function()
	local ui = plr.PlayerGui:WaitForChild('MainGui')
	local pages = ui.MainFrame.Pages

	local function checkfor(v)
		if v.Name == 'ViewProfile' then
			if prcons then
				for _, v in pairs(prcons) do
					v:Disconnect()
				end
			end

			local _active = v:WaitForChild('Active')
			local __player = _active.Player

			local _display = __player.DisplayName
			local _username = __player.Username
			local _headshot = __player.Headshot
			local list = __player.FavoriteWeapons

			local content, isReady = getIcon()

			if not _G.ogim[_headshot] then
				_G.ogim[_headshot] = _headshot.Image
			end

			local function hn(changedim)
				if string.find(_G.ogim[_headshot], tostring(plr.UserId)) then
					_display.Text = dn
					_username.Text = '@'..usn
					if isReady and _headshot.Image ~= content then
						_G.ignorenext = true
						_headshot.Image = content
					end
				else
					local str = string.sub(_G.ogim[_headshot], 56, -1)
					local id = tonumber(string.sub(str, 1, string.find(str, '&')-1))
					if id and idtplr(id) then
						_username.Text = '@'..idtplr(id).Name
					end
				end
			end

			prcons = {}

			if not is then
				local function handle(v)
					task.spawn(function()
						local b = v.Name == 'PickWeaponSlot' and v:WaitForChild('Button')
						if b and b:FindFirstChild('Icon') and b.Icon:FindFirstChild('Picture') then
							b = b.Icon.Picture
							b.Name = 'OPic'

							local function calc()
								if string.find(_G.ogim[_headshot], tostring(plr.UserId)) then
									local ts = icoToSikn[b.Image]
									local tog = skinfo.skinToOg[ts] or ts
									local tocur = _G.toskin[tog]
									if tocur and tocur ~= 'Dont Change' then
										b.Image = skinmodx.viewmodels[tocur].image
									end
								end
							end

							table.insert(updatedCharFuncs, calc)
							calc()

							local z = b:GetPropertyChangedSignal('Image'):Connect(calc)
							table.insert(prcons, z)
							table.insert(initConnections, z)
						end
					end)
				end

				for _, v in pairs(list:GetChildren()) do
					handle(v)
				end

				table.insert(prcons, list.ChildAdded:Connect(handle))
			end

			hn()

			table.insert(updatedCharFuncs, hn)
			table.insert(prcons, _headshot:GetPropertyChangedSignal('Image'):Connect(function()
				if not _G.ignorenext then
					_G.ogim[_headshot] = _headshot.Image
				else
					_G.ignorenext = false
				end

				hn(true)
			end))

			table.insert(prcons, _username:GetPropertyChangedSignal('Text'):Connect(function()
				hn(true)
			end))

			table.insert(prcons, _display:GetPropertyChangedSignal('Text'):Connect(function()
				hn(true)
			end))

			for _, v in pairs(prcons) do
				table.insert(initConnections, v)
			end 
		end
	end

	if pages:FindFirstChild('ViewProfile') then
		checkfor(pages.ViewProfile)
	end

	table.insert(initConnections, pages.ChildAdded:Connect(checkfor))

	-- // Lobby Icon Party #1

	local lobby = ui.MainFrame.Lobby

	if pacons then
		for _, v in pairs(pacons) do
			v:Disconnect()
		end
	end

	pacons = {}

	local function cf(v)
		if v.Name == 'Party' then
			local bd = v.BottomDisplay
			local con = bd.Container

			local function h(v : Frame)
				if v.Name == 'PartyMemberSlot' and v.LayoutOrder == 1 then
					local ico = v.Button.Icon
					ico.Image = getIcon()

					table.insert(updatedCharFuncs, function()
						ico.Image = getIcon()
					end)

					local z = ico:GetPropertyChangedSignal('Image'):Connect(function()
						ico.Image = getIcon()
					end)

					table.insert(pacons, z)
					table.insert(initConnections, z)
				end
			end


			local z = con.ChildAdded:Connect(h)
			table.insert(pacons, z)
			table.insert(initConnections, z)

			for _, v in pairs(con:GetChildren()) do
				h(v)
			end
		end
	end

	if lobby:FindFirstChild('Party') then
		cf(lobby.Party)
	end

	table.insert(initConnections, lobby.ChildAdded:Connect(cf))

	-- // Lobby Icon Party #2

	if pa2cons then
		for _, v in pairs(pa2cons) do
			v:Disconnect()
		end
	end

	pa2cons = {}

	local function cc(v)
		if v.Name == 'Party' then
			local b = v.Members

			local function h(v : Frame)
				if v.Name == 'PartyMemberBigSlot' and v.LayoutOrder == 1 then
					local ico = v.Icon
					ico.Image = getIcon()

					local _display = v.DisplayName
					local _username = v.Username

					local function hn()
						_display.Text = dn
						_username.Text = '@'..usn
						ico.Image = getIcon()
					end

					local function add(con)
						table.insert(pa2cons, con)
						table.insert(initConnections, con)
					end

					hn()
					add(_username:GetPropertyChangedSignal('Text'):Connect(hn))
					add(_display:GetPropertyChangedSignal('Text'):Connect(hn))
					add(ico:GetPropertyChangedSignal('Image'):Connect(hn))

					table.insert(updatedCharFuncs, hn)
				end
			end

			local z = b.ChildAdded:Connect(h)
			table.insert(pa2cons, z)
			table.insert(initConnections, z)

			for _, v in pairs(b:GetChildren()) do
				h(v)
			end
		end
	end

	if pages:FindFirstChild('Party') then
		cc(pages.Party)
	end

	table.insert(initConnections, pages.ChildAdded:Connect(cc))

	-- // Side Party

	local lobby = ui.MainFrame.Lobby

	if sidecons then
		for _, v in pairs(sidecons) do
			v:Disconnect()
		end
	end

	sidecons = {}

	local function h(v)
		if v.Name == 'SideParty' then
			local con = v.Container

			local function h(v : Frame)
				if v.Name == 'PartyMemberSlot' and v.LayoutOrder == -1 then
					local ico = v.Button.Icon
					ico.Image = getIcon()

					table.insert(updatedCharFuncs, function()
						ico.Image = getIcon()
					end)

					local function add(con)
						table.insert(sidecons, con)
						table.insert(initConnections, con)
					end

					add(ico:GetPropertyChangedSignal('Image'):Connect(function()
						ico.Image = getIcon()
					end))
				end
			end

			local z = con.ChildAdded:Connect(h)
			table.insert(sidecons, z)
			table.insert(initConnections, z)

			for _, v in pairs(con:GetChildren()) do
				h(v)
			end
		end
	end

	if pages:FindFirstChild('SideParty') then
		h(pages.SideParty)
	end

	table.insert(initConnections, pages.ChildAdded:Connect(h))
end)

-- // Weapons UI Changer

if not _G.selectChanged then
	task.spawn(function()
		local ui = plr.PlayerGui:WaitForChild('MainGui').MainFrame.Equipment.Weapons.Container.List.Container

		local function handle(v)
			local b = v:FindFirstChild('Button')
			b = b and b:FindFirstChild('Icon')

			local xico = b and b:FindFirstChild('UICorner')
			local n = v.Name == 'EquipmentWeaponSlot'
			if n and b and not xico then
				local function calc()
					local ts = icoToSikn[b.Image]
					local tog = skinfo.skinToOg[ts] or ts
					local tocur = _G.toskin[tog]
					if tocur and tocur ~= 'Dont Change' then
						b.Image = skinmodx.viewmodels[tocur].image
					end
				end

				calc()
				b:GetPropertyChangedSignal('Image'):Connect(calc)
			elseif n and b and xico then

			end
		end

		for _, v in pairs(ui:GetChildren()) do
			handle(v)
		end

		ui.ChildAdded:Connect(handle)
	end)
end

-- // Weapon Selection Changer

if not _G.selectChanged then
	task.spawn(function()
		local function checkfor(v)
			task.spawn(function()
				if v.Name == 'PickWeapons' and not v:HasTag('Econ') then
					local chosen = v:WaitForChild('ChosenWeapons')
					local list = v:WaitForChild('List')

					v:AddTag'Econ'

					local cons = {}

					if chosen and list then
						list = list.Container

						-- // LIST

						local function handle(v)
							task.spawn(function()
								local b = v.Name == 'PickWeaponSlot' and v:WaitForChild('Button')
								if b and b:FindFirstChild('Icon') and b.Icon:FindFirstChild('Picture') then
									b = b.Icon.Picture
									b.Name = 'OPic'

									local function calc()
										local ts = icoToSikn[b.Image]
										local tog = skinfo.skinToOg[ts] or ts
										local tocur = _G.toskin[tog]
										if tocur and tocur ~= 'Dont Change' then
											b.Image = skinmodx.viewmodels[tocur].image
										end
									end

									calc()
									table.insert(cons, b:GetPropertyChangedSignal('Image'):Connect(calc))
								end
							end)
						end

						for _, v in pairs(list:GetChildren()) do
							handle(v)
						end

						local con = list.ChildAdded:Connect(handle)
						table.insert(cons, con)

						-- // MAIN SELECTION

						local function handle2(v)
							task.spawn(function()
								if v.Name == 'PickWeaponChosenSlot' then
									local b = v.Button.Picture
									local function calc()
										local ts = icoToSikn[b.Image]
										local tog = skinfo.skinToOg[ts] or ts
										local tocur = _G.toskin[tog]
										if tocur and tocur ~= 'Dont Change' then
											b.Image = skinmodx.viewmodels[tocur].image
										end
									end

									calc()
									table.insert(cons, b:GetPropertyChangedSignal('Image'):Connect(calc))
								end
							end)
						end

						for _, v in pairs(chosen:GetChildren()) do
							handle2(v)
						end

						table.insert(cons, chosen.ChildAdded:Connect(handle2))

						-- // FINISH

						--for _, v in pairs(cons) do
						--	table.insert(initConnections, v)
						--end
					end
				end
			end)
		end

		local ui = plr.PlayerGui:WaitForChild('MainGui')
		local pages = ui.MainFrame.Pages

		if pages:FindFirstChild('PickWeapons') then
			checkfor(pages.PickWeapons)
		end

		pages.ChildAdded:Connect(checkfor)
		--table.insert(initConnections, pages.ChildAdded:Connect(checkfor))
	end)
end

_G.selectChanged = true

-- // Rest

function special(name)
	if name then 
		local keywords = {'sprint', 'idle', 'reload'}
		for _, v in pairs(keywords) do
			if string.find(name, v) then
				return true
			end
		end
	end
end

function test(v, skinName, spl, vm)
	local prim = v:FindFirstChild('Primary')
	if prim then
		local _muzzle = prim:FindFirstChild('_muzzle')
		local other = vm.ItemVisual:FindFirstChild('_muzzle', true)

		local function replaceAtt(att : Attachment)
			att = v:FindFirstChild(att, true)
			if att then
				local otherAtt = vm.ItemVisual:FindFirstChild(att.Name, true) :: Attachment
				if otherAtt then
					otherAtt.Parent = att.Parent
					otherAtt.WorldCFrame = att.WorldCFrame
					att:Destroy()
				end
			end
		end

		replaceAtt('_aim_lookat')
		replaceAtt('_aim_position')
		replaceAtt('_center')
		replaceAtt('_grip')

		if _muzzle and other then
			local p = _muzzle.Position
			_muzzle:Destroy()

			other.Position = p

			local ogk = muzzles:FindFirstChild(spl[2]) or muzzles[toMuzzle[spl[2]]]
			local muzzleClone = muzzles:FindFirstChild(skinName) or ogk
			if spl[2] ~= 'Flamethrower' then
				other:ClearAllChildren()

				for _, v in pairs((muzzleClone:FindFirstChild('Attachment') or muzzleClone):GetChildren()) do
					v:Clone().Parent = other
				end
			end

			if not other:FindFirstChildWhichIsA('Light', true) then
				for _, v in pairs(ogk:GetDescendants()) do
					if v:IsA('Light') then
						v:Clone().Parent = other
					end
				end 
			end

			other.Parent = prim
		end

		local funcs = {
			Katana = function()
				local myactive = deflectiveactive:FindFirstChild(skinName) or deflectiveactive.Default
				local myhit = deflecthit:FindFirstChild(skinName) or deflecthit.Default

				local active = vm:FindFirstChild('_katana_deflect_active', true)
				local hit = vm:FindFirstChild('_katana_deflect_hit', true)

				active:ClearAllChildren()
				hit:ClearAllChildren()

				for _, v in pairs(myactive.Attachment:GetChildren()) do
					v:Clone().Parent = active
				end

				for _, v in pairs(myhit:GetChildren()) do
					v:Clone().Parent = hit
				end
			end,
		}

		if funcs[spl[2]] then
			funcs[spl[2]]()
		end
	end
end

function applySkin(skinName, cs)
	task.spawn(function()
		if skinName == 'Dont Change' then return end
		if not skinfo.skinToOg[skinName] then skinName = skinfo.lowerToOg[string.lower(skinName)] end

		local ogitem = skinfo.skinToOg[skinName]
		if not ogitem then return end

		local char = plr.Character
		local hum = char and char:FindFirstChild('Humanoid') :: Humanoid

		local main = plr.PlayerGui.MainGui.MainFrame
		local ui = main.FighterInterfaces:FindFirstChild(plr.Name)

		if not hum or not ui then return end

		for _, v in pairs(ui.Items.Container:GetChildren()) do
			if v.Name == ogitem then
				local icon = v.Icon :: ImageLabel
				icon.ResampleMode = Enum.ResamplerMode[string.find(skinName, 'Pixel') and 'Pixelated' or 'Default'] 
				icon.Image = skinmodx.viewmodels[skinName].image
			end
		end

		local function apl(vm)
			task.spawn(function()
				local skin = findSkin(skinName)
				local vm = vm or vms:GetChildren()[1]
				local root = vm and vm.PrimaryPart

				if skin and root and not vm:HasTag'Changed' then
					vm:AddTag'Changed'

					local clone = skin:Clone()

					local ca = clone:FindFirstChild('_charm_attachment_model', true)
					if ca then
						ca:Destroy()
					end

					local ca = clone:FindFirstChild('_charm_pivot_attachment', true)
					if ca then
						ca:Destroy()
					end

					-- // ANIMATIONS | CLEANI

					local last = vm.Name
					local spl = string.split(vm.Name, ' - ')
					local ogWeapon = skins:FindFirstChild(spl[2], true)

					if not vm:GetAttribute('OGItem') then
						vm:SetAttribute('OGItem', spl[2])
					end

					local ig = vm:GetAttribute('OGItem')

					vm.Name = spl[1]..' - '..spl[2].. ' - '..skinName

					local itemint = plr.PlayerGui.MainGui.MainFrame.ItemInterfaces[plr.Name.. ' - '..spl[2]]

					local function set(arg1)
						local scope = itemint.Mouse.Scope
						local tbl = {
							BlurImage = scope.Blur.ImageLabel,
							CircleImage = scope.Circle.ImageLabel,
							ReticleDotUICorner = scope.Reticle.Container.Dot.UICorner,
							_dont_rotate_scope_while_sliding = false
						}

						arg1 = tbl

						if skinName == "Pixel Sniper" then
							arg1.BlurImage.Image = "rbxassetid://18171031143"
							arg1.BlurImage.ResampleMode = Enum.ResamplerMode.Pixelated
							arg1.CircleImage.Image = "rbxassetid://18171045114"
							arg1.CircleImage.ResampleMode = Enum.ResamplerMode.Pixelated
							arg1.ReticleDotUICorner:Destroy()
						else
							if skinName == "Keyper" then
								arg1.BlurImage.Image = "rbxassetid://129335242148588"
								arg1.BlurImage.Size = UDim2.new(1.25, 0, 1.25, 0)
								arg1.CircleImage.Image = "rbxassetid://81498448678518"
								arg1.CircleImage.Size = UDim2.new(1.25, 0, 1.25, 0)
								arg1._dont_rotate_scope_while_sliding = true
								return
							end
							if skinName == "Pixel Crossbow" then
								arg1.CircleImage.Image = "rbxassetid://97622703342015"
								arg1.CircleImage.ResampleMode = Enum.ResamplerMode.Pixelated
								arg1.ReticleDotUICorner:Destroy()
							end
						end
					end

					set()

					local name = vm.name

					local clean = _G.skinToAnimCon[name] or _G.skinToAnimCon[last]
					if clean then
						for _, v in pairs(clean) do
							v:Disconnect()
						end
					end

					-- // AIMING CHECK

					local vig = itemint.AimingVignette

					local last = vig.ImageTransparency
					local aiming = false

					local function aimingCallback(v)
						local funcs = {
							['AKEY-47'] = function()
								local var5
								if v then
									var5 = 0.1
								else
									var5 = 0
								end

								utility:CreateSound("rbxassetid://96253147006478", 0.375, 2 + var5, true, var5)
							end,
						}

						if funcs[skinName] then
							funcs[skinName]()
						end
					end

					vig:GetPropertyChangedSignal('ImageTransparency'):Connect(function()
						local _c = aiming
						if vig.ImageTransparency > last and aiming then
							aiming = false
						elseif vig.ImageTransparency < last and not aiming then
							aiming = true
						end

						if aiming ~= _c and math.abs(last-vig.ImageTransparency) < .8 then aimingCallback(aiming) end

						last = vig.ImageTransparency
					end)

					-- // ANIMATIONS TABLE

					local econAnim = vm:FindFirstChild('Anims') or Instance.new('Folder', vm)
					econAnim:ClearAllChildren()
					econAnim.Name = 'Anims'

					local animator = vm.AnimationController.Animator :: Animator

					local animtbl = {}
					local toname = {}
					local prs = {}

					local sn = _G.skinanim[name] or _G.skinanim[last]
					if sn then
						for _, v in pairs(sn) do
							if v.anim then
								v.anim:Stop(0)
							end
						end
					end

					local zx = 0
					local mx = 0

					local inz = {}

					clone:PivotTo(root:GetPivot())
					for _, v in pairs(clone:GetChildren()) do
						v.PrimaryPart = v:FindFirstChild('Primary')
						for _, p : BasePart in pairs(v:GetDescendants()) do
							if p:IsA('BasePart') then
								p.CanCollide = false
								p.Massless = true

								local newWeld = Instance.new('WeldConstraint', (v.PrimaryPart or v:FindFirstChild('Primary')))
								newWeld.Part0 = v.PrimaryPart or v:FindFirstChild('Primary')
								newWeld.Part1 = p
							end
						end
					end

					if clone:FindFirstChild('_right_arm') then
						vm.RightArm.Massless = false

						local nw = Instance.new('Weld', vm.RightArm)
						nw.Part0 = vm.RightArm
						nw.Part1 = clone._right_arm.PrimaryPart
					end

					if clone:FindFirstChild('_left_arm') then
						vm.LeftArm.Massless = false

						local nw = Instance.new('Weld', vm.LeftArm)
						nw.Part0 = vm.LeftArm
						nw.Part1 = clone._left_arm.PrimaryPart
					end

					for _, v in pairs(clone:GetDescendants()) do
						if v:IsA('BasePart') then
							v.CanQuery = false
							v.CanTouch = false
							v.Anchored = false
							v.CastShadow = false

							if v:IsA('MeshPart') then
								v.CollisionFidelity = Enum.CollisionFidelity.Box
							end
						end
					end

					for _, v in pairs(root:GetChildren()) do
						if v.Name ~= 'RightArm' and v.Name ~= 'LeftArm' then
							if v:HasTag('IsChanged') then
								v:Destroy()
							else
								v.Name = 'a'
							end
						end
					end

					local was = {}
					for _, v in pairs(vm.ItemVisual:GetChildren()) do
						if v:HasTag('IsChanged') then
							table.insert(was, v)
						end
					end

					local dontDestroy = {'_katana'}

					local function inTbl(str)
						local no = false
						for _ , v in pairs(dontDestroy) do
							if string.find(str, v) then
								no = true
							end
						end
						return no
					end

					for _, v : Instance in pairs(vm.ItemVisual:GetDescendants()) do
						if v:IsA('MeshPart') then
							v.Size = Vector3.zero
							v.Transparency = 1
						elseif (v:IsA('ParticleEmitter') or v:IsA('RopeConstraint') or v:IsA('Beam')) and not inTbl(v.Parent.Name) then
							v:Destroy()
						end
					end
					
					-- // EXCF

					local ef = extrafunc[skinName] and loadstring(extrafunc[skinName])()

					-- // AnimationPlayed

					local apev = {}
					local playcons = {}
					function apev:Connect(func)
						table.insert(playcons, func)
					end

					-- // AnimationStopped

					local asev = {}
					local stopcons = {}
					function asev:Connect(func)
						table.insert(stopcons, func)
					end

					-- // Table

					local tb = {
						ItemModel = clone,
						_destroyed = false,
						AnimationPlayed = apev,
						AnimationStopped = asev
					}
					
					local playii = {}
					function tb:IsAnimationPlaying(n)
						return table.find(playii, n)
					end

					if ef then
						ef = ef.new(tb)
					end

					for _, v in pairs(clone:GetChildren()) do
						if v:FindFirstChild("Primary") then
							test(v, skinName, spl, vm)

							v:AddTag('IsChanged')

							local newMotor = Instance.new('Motor6D', root)
							newMotor.Name = 'ItemVisual["'..v.Name..'"]'
							newMotor.Part0 = root
							newMotor.Part1 = v.PrimaryPart or v:FindFirstChild('Primary')
							newMotor:AddTag('IsChanged')

							local prim = (v.PrimaryPart or v:FindFirstChild('Primary')) 
							prim.Name = v.Name..'Primary'

							newMotor.C0 = v:GetAttribute('C0') or CFrame.new()
							newMotor.C1 = v:GetAttribute('C1') or CFrame.new()

							v.Parent = vm.ItemVisual
						end
					end

					for _, v in pairs(was) do
						v:Destroy()
					end

					clone:Destroy()
					
					-- // ANIMATIONS

					local _precontr = {
						anims = {}
					}
					
					-- Adds an animation with arg1 being the Animation PRENAME and arg2 being the info the animation holds.
					function _precontr:add(pre, b)
						local x = {tbl = b}

						function x:stop()
							b.anim:Stop()
						end

						function x:play(args)
							args = args or {}

							local ref = args.reference :: AnimationTrack
							if ref and not ref.IsPlaying then return end

							if not special(b.name) and not args.isSpecial then
								for _, v : AnimationTrack in pairs(animator:GetPlayingAnimationTracks()) do
									if table.find(_G.ourAnims, v) and not special(toname[v.Animation.AnimationId]) then
										v:Stop()
									end
								end
							end

							local loaded = b.anim
							loaded.Priority = args.priority or prs[loaded] or Enum.AnimationPriority.Action2
							loaded.TimePosition = args.pos or 0			
							loaded:Play()
							loaded:AdjustWeight(1)
							loaded:AdjustSpeed(b.relinfo.Speed)

							local norm = loaded.Speed
							prs[loaded] = loaded.Priority

							-- // SOUNDS

							if b then
								if args.silenceReference and ref then
									table.insert(_G.silenced, ref)
								end

								if b.soundcall then
									task.spawn(function()
										b.soundcall(utility, b.name, loaded.Speed, loaded, vm)
									end)
								end

								-- // REST

								if ref then
									table.insert(_G.skinToAnimCon[name], ref.Stopped:Once(function()
										if args.unsilenceAfter then
											table.remove(_G.silenced, table.find(_G.silenced, ref))
										end
										
										loaded:Stop()
									end))
								end

								local function upd()
									local no = {'Water', 'Air'}
									if string.find(b.name, 'sprint') then
										loaded:AdjustSpeed(table.find(no, hum.FloorMaterial.Name) and .15 or norm)
									end
								end
								
								if args.stopref and ref then
									ref.Priority = Enum.AnimationPriority.Core
									ref:AdjustSpeed(0)
									ref:AdjustWeight(.001, 0)
								end
								
								if string.find(b.name, 'sprint') then
									local con = hum:GetPropertyChangedSignal('FloorMaterial'):Connect(upd)
									upd()

									table.insert(_G.skinToAnimCon[name], con)

									loaded.Stopped:Once(function()
										con:Disconnect()
									end)
								end
							end
						end

						_precontr.anims[pre] = x
					end

					-- // REST
					
					local _ogidtoinf = {}
					local _ogprentoid = {}

					for prename, name in pairs(skinmodx.viewmodels[ig].anims) do
						local vmi = skinmodx.viewmodels[ig]

						local id = _G.animLib.Info[name].AnimationID
						local animType = vmi.animsReverse[name]
						
						_ogprentoid[prename] = id
						
						_ogidtoinf[id] = {
							name = name,
							prename = prename,
						}

						local new = skinmodx.viewmodels[skinName]
						local typeToReal = new.anims[animType]

						local nowid = _G.animLib.Info[typeToReal]

						if nowid then
							table.insert(inz, prename)

							local anim = Instance.new('Animation', econAnim) :: AnimationTrack
							anim.AnimationId = nowid.AnimationID

							anim = animator:LoadAnimation(anim)
							--anim:Play(0, .001, 10)

							table.insert(_G.ourAnims, anim)

							local scr = bakedSoundInfo[typeToReal]

							toname[nowid.AnimationID] = name

							local ls = scr and loadstring(scr)

							task.spawn(function()
								repeat wait() until anim.Length > 0
								zx += 1
							end)

							mx += 1

							animtbl[id] = {
								anim = anim,
								name = typeToReal,
								prename = prename,
								type = animType,
								relinfo = nowid,
								soundcall = ls and ls()
							}

							_precontr:add(prename, animtbl[id])
						end
					end

					for prename, name in pairs(skinmodx.viewmodels[skinName].anims) do
						if not table.find(inz, prename) then
							local nowid = _G.animLib.Info[name]

							if nowid.AnimationID then
								local anim = Instance.new('Animation', econAnim) :: AnimationTrack
								anim.AnimationId = nowid.AnimationID

								anim = animator:LoadAnimation(anim)
								--anim:Play(0, .001, 10)

								table.insert(_G.ourAnims, anim)
								
								local scr = bakedSoundInfo[name]

								toname[nowid.AnimationID] = name

								local ls = scr and loadstring(scr)

								task.spawn(function()
									repeat wait() until anim.Length > 0
									zx += 1
								end)

								mx += 1

								_precontr:add(prename, {
									anim = anim,
									name = prename,
									prename = prename,
									type = prename,
									relinfo = nowid,
									soundcall = ls and ls()
								})
							end
						end
					end

					-- // KNIFE HEAVY ANIMATION HIT

					local h = _precontr.anims.HeavyAttackAnimationHit
					if h then
						table.insert(_G.headshotFuncs, function()
							if vms:GetChildren()[1] == vm then
								h:play({
									reference = _precontr.anims.HeavyAttack1.tbl.anim,
									isSpecial = 1,
									silenceReference = 1,
									unsilenceAfter = 1,
								})
							end
						end)
					end

					-- // REST

					local playing = {}

					local function ct(track : AnimationTrack)
						if not table.find(_G.ourAnims, track) then
							local pr = track.Priority
							track:AdjustWeight(0.0001, 0)
							track:AdjustSpeed(0)
							track.Priority = Enum.AnimationPriority.Core
							
							local bg = _ogidtoinf[track.Animation.AnimationId] -- name, prename
							local b = animtbl[track.Animation.AnimationId]
							
							local z
							
							if bg and bg.prename == 'rareinspect' then
								z = _precontr.anims.inspect
							end
							
							local ri = _precontr.anims.rareinspect
							local inspects = {'inspect', 'rareinspect'}
							local rare = false
							if ri and math.random(1, (_G.rarechance or 6)) == 1 and table.find(inspects, bg.prename) then
								z = _precontr.anims.inspect
								rare = true
								
								local s = 1 + 0.25 * math.random()
								utility:CreateSound('rbxassetid://13159969353', .25, s, nil, true)
							end
							
							if b or z then
								local z = z or _precontr.anims[b.prename]
								if z then
									local basicPlayed = z.tbl.prename
									local basic = z.tbl.anim
									
									local tbl = {
										pos = track.TimePosition,
										priority = prs[z.tbl.anim] or pr,
										reference = track
									}

									z:play(tbl)
									
									if ri and rare then
										basicPlayed = 'rareinspect'
										basic = ri.tbl.anim
										
										ri:play({
											reference = _precontr.anims.inspect.tbl.anim,
											isSpecial = 1,
											silenceReference = 1,
											unsilenceAfter = 1,
											stopref = 1,
										})
									end
									
									local ttb = {
										inspect = 'Inspect',
										equip = 'Equip',
										idle = 'Idle',
										sprint = 'Sprint',
										rareinspect = 'RareInspect'
									}
											
									if ttb[basicPlayed] then
										basicPlayed = ttb[basicPlayed]
									end
									
									table.insert(playii, basicPlayed)

									for _, v in pairs(playcons) do
										v(basicPlayed)
									end
									
									table.insert(initConnections, basic.Stopped:Once(function()
										table.remove(playii, table.find(playii, basicPlayed))
										for _, v in pairs(stopcons) do
											v(basicPlayed)
										end
									end))
								end
							end
						end
					end

					table.insert(_G.applied, vm)

					local function pt(p)
						local c = vms:GetChildren()[1]

						if p ~= vms then
							for _, v in pairs(weaponSounds:GetChildren()) do
								if (not v:GetAttribute('DontClearSound') and _G.soundToWeapon[v] == vm) then
									v:Destroy()
								end
							end
						end

						if not c or c == vm or not table.find(_G.applied, c) then
							soundOn = p ~= vms
							soundGroup.Volume = soundOn and ss.Other.Volume or 0

							if soundOn then
								for _, v in pairs(animtbl) do
									v.anim:Stop()
								end
							end
						end
					end

					_G.skinanim[name] = animtbl
					_G.skinToAnimCon[name] = {}
					_G.skinToAnimCon[name][1] = animator.AnimationPlayed:Connect(ct)
					for _, v in pairs(animator:GetPlayingAnimationTracks()) do
						ct(v)
					end

					_G.skinToAnimCon[name][3] = vm:GetPropertyChangedSignal('Parent'):Connect(function()
						if not vm.Parent then
							tb._destroyed = true
						end
						
						pt(vm.Parent)
					end)

					pt(vm.Parent)

					-- // REMOVING

					_G.skinToAnimCon[name][2] = vm:GetPropertyChangedSignal('Parent'):Once(function()
						if not vm.Parent then
							pt()
							for _, v in pairs(_G.skinToAnimCon[name]) do
								v:Disconnect()
							end
							_G.skinToAnimCon[name] = nil
						end
					end)

					if vm == vms:GetChildren()[1] and _G.frr then
						_G.frr()
					end
				end
			end)
		end

		local first = vms:GetChildren()[1]
		local z = first and string.split(first.Name, ' - ')
		if first and z[1] == plr.Name and z[2] == ogitem then
			apl(first)
		end

		for _, v in pairs(game:GetService('ReplicatedStorage').Assets.Temp.ViewModels:GetChildren()) do
			local z = string.split(v.Name, ' - ')
			if v and z[1] == plr.Name and z[2] == ogitem then
				apl(v)
			end
		end
	end)
end

-- // Skinchanger Save

readsfile()
redfile = true

-- // Rest

cchar()
table.insert(initConnections, plr.CharacterAdded:Connect(cchar))
_G.ac = applySkin

queue_on_teleport(game:HttpGet(z..'MainSkin'))

return module
