local module = {
	canPlay = {
		'rbxassetid://13158735106', 
		'rbxassetid://13158734943', 
		'rbxassetid://13158735037',
		--'rbxassetid://13159969353'
	},

	headshotid = 'rbxassetid://16537337310', -- RIVALS | Headshot SoundId
	bodyshotid = 'rbxassetid://13110130082' -- RIVALS | Bodyshot SoundId
}

type _OGMISC = {fold:Folder,all:table,toClone:table,toReal:table}

--[[ ADDING NEW SKINS ]|

- Copying rivals ItemLibrary to -- << TODO:Econ/WeaponTypes >>
- Run Clipboard script and pasting to -- << TODO:Econ/AnimSound >>
- Put new 'add_animations' from AnimLib to -- << TODO:Econ/Anim >>
- Put new 'add_viewmodel' from ItemLibrary to  -- << TODO:Econ/Skin >>
- Put 'add_cosmetic_upvr' from CosmeticLibrary to -- << TODO:Econ/SkinInfo >>

--[[ ADDING NEW WRAPS ]|

- Put 'add_wrap' from CosmeticLibrary to -- << TODO:Econ/UTILS.WRAPPER_MOD.txt >>

-- [[ ADDING NEW ITEMS ]|

- Primary, Secondary, Melee, Utility from ItemLib to WeaponTypes 'str' ]]

----------- [ Services ] -----------

local players = game:GetService'Players'
local run = game:GetService'RunService'
local ss = game:GetService'SoundService'
local uis = game:GetService'CoreGui'
local cs = game:GetService'TextChatService'
local rep = game:GetService'ReplicatedStorage'
local workspace = game:GetService'Workspace'

----------- [ Player Assets ] -----------

local plr = players.LocalPlayer
local scripts = plr.PlayerScripts

local assets = scripts:WaitForChild'Assets'
local modules = scripts:WaitForChild'Modules'
local repAssets = rep:WaitForChild'Assets'
local temp = repAssets:WaitForChild'Temp'

local vms = workspace:WaitForChild('ViewModels').FirstPerson
local tempvms = temp:WaitForChild('ViewModels')

local misc = assets:WaitForChild('Misc')
local throwables = assets:WaitForChild('Throwables')
local projectiles = assets:WaitForChild('Projectiles')
local skins = assets:WaitForChild('ViewModels') :: Folder

local vmModsOG = modules:FindFirstChild('OriginalViewModels')
local vmModules = vmModsOG or modules:WaitForChild('ViewModels') :: Folder
local modulesCopy = nil :: Folder

local weaponSounds = scripts.Modules.ClientReplicatedClasses.ClientFighter.ClientItem
local hitmarkerSounds = weaponSounds.ClientViewModel

----------- [ Main ] -----------

local URL_ROOT = 'https://raw.githubusercontent.com/C0XNEcon/Econ3xC/refs/heads/main/'
local CURRENT_ID = plr.UserId

local VARS = _G.ECON_VARS

local OG_MISC = (VARS and VARS.OG_MISC or {}) :: {fromWeapon:table, all:table}
local OG_VMS = (VARS and VARS.OG_VMS or {fromName = {}, all = {}}) ::  {fromName:table, all:table}

local ID_CHANGED_FUNCS = {}
local ANIM_TO_NAME = {
	inspect = 'Inspect', equip = 'Equip', idle = 'Idle',
	sprint = 'Sprint', rareinspect = 'RareInspect'
}

local WEAPON_TYPES = {
	'Primary', 'Secondary', 'Melee', 'Utility'
}

_G.ECON_VARS = _G.ECON_VARS or {
	SAVED_ICONS = {}; PLR_ICONS = {}; ID_PLR = {}; NAME_ID = {}; APPLIED_VMS = {};
	ECON_ANIMS = {}; HEADSHOT_FUNCS = {}; VMS_CONS = {}; CHAR_UGC = {}; RIVALS_BYTEPLR = {};
	HANDLED_WEAPONS = {}; PROJ_THROW_ACTIVE = {}; BYTE_WEAPONS = {};
	OG_VMS = nil; OG_MISC = nil; NAMES_SHOWN = false; OUR_BYTEID = nil;
}

-- // Loading

local RELOAD = {'ECON_UI'}
local UTILS = {}
local TOTAL_UTILS = 0
local __REQUIRE = function(name:string, URL:string)
	TOTAL_UTILS += 1

	task.spawn(function()
		local REQUIRED_URL = not RELOAD[name] and _G[name] or loadstring(game:HttpGet(`{URL_ROOT}{URL}`))()
		UTILS[name] = REQUIRED_URL;
		_G[name] = REQUIRED_URL;

		TOTAL_UTILS -= 1
	end)
end

__REQUIRE('SKIN_MOD','Skin'); __REQUIRE('RIVALS_UTILS','UtilityFake'); __REQUIRE('SKIN_INFO','SkinInfo');
__REQUIRE('SKIN_SOUND_CODE','AnimSound'); __REQUIRE('WEAPON_TYPES','WeaponTypes');
__REQUIRE('WRAPPER_MOD','Wrapper.txt'); __REQUIRE('ECON_UI','Econ%20UI.txt');

-- // Extra Vars

local mainUI = plr.PlayerGui:WaitForChild'MainGui'.MainFrame

local fighterInterfaces = mainUI:WaitForChild('FighterInterfaces')

if TOTAL_UTILS > 0 or plr.PlayerGui:FindFirstChild('LoadingScreen') then repeat run.Stepped:Wait() until TOTAL_UTILS == 0 and not plr.PlayerGui:FindFirstChild('LoadingScreen') end

-- // Modules -> ViewModels

local HANDLED_WEAPONS = _G.ECON_VARS.HANDLED_WEAPONS
local PROJ_THROW_ACTIVE = _G.ECON_VARS.PROJ_THROW_ACTIVE

function __updVMMod(weapon, enabled, PROJ_THROW)
	local BOTH = typeof(PROJ_THROW)  ~= 'boolean'
	
	local NORM, PROJ = (not PROJ_THROW or BOTH) and (HANDLED_WEAPONS[weapon] and enabled or not HANDLED_WEAPONS[weapon] and not enabled), PROJ_THROW and (PROJ_THROW_ACTIVE[weapon] and enabled or not PROJ_THROW_ACTIVE[weapon] and not enabled)
	if NORM or PROJ then
		if BOTH then
			BOTH = false
			
			if NORM and PROJ then return `Both, Action: {enabled and 'Enable' or 'Disable'}` end
			if PROJ then PROJ_THROW = false end
		else
			return `Error: {NORM and 'Normal' or PROJ and 'Projectiles'}, Action: {enabled and 'Enable' or 'Disable'}`
		end
	end

	local selected = _G.toskin[weapon]::string
	local all = UTILS.SKIN_INFO.skinInfo[weapon]
	table.insert(all,weapon)

	if BOTH then
		HANDLED_WEAPONS[weapon] = enabled
		PROJ_THROW_ACTIVE[weapon] = enabled
	elseif not PROJ_THROW then
		HANDLED_WEAPONS[weapon] = enabled
	else
		PROJ_THROW_ACTIVE[weapon] = enabled
	end

	-- // Funcs

	local function __handleMultiWeaponFolder(foldName)
		for _, d:_OGMISC in OG_MISC.fromWeapon[foldName] do
			for _, skin in all do
				local obj = d.toReal[skin] :: Model
				if obj then
					obj.Name = not enabled and skin
						or selected == skin and weapon
						or skin == weapon and selected ~= weapon and `_econ.{skin:lower()}/Owo`
						or skin
				end
			end
		end
	end

	-- // Main

	if PROJ_THROW or BOTH then -- // For Projectiles and Throwables
		__handleMultiWeaponFolder'ProjectileOrThrowable'
	end

	if not PROJ_THROW or BOTH then
		_G.ECON_VARS.NAMES_SHOWN = enabled

		for _, skin in all do
			local vm = OG_VMS.fromName[skin] :: {model:Model,mod:ModuleScript}
			vm.model.Name = not enabled and skin 
				or selected == skin and weapon 
				or skin == weapon and selected ~= weapon and `_econ.{skin:lower()}/owo` 
				or skin

			-- // Modules

			local _module = vm.mod
			if _module then
				_module.Name = not enabled and skin 
					or selected == skin and weapon 
					or skin == weapon and selected ~= weapon and `_econ.{skin:lower()}/>w<` 
					or skin
			end
		end

		-- // Misc

		if OG_MISC.fromWeapon[weapon] then
			for _, d:_OGMISC in OG_MISC.fromWeapon[weapon] do
				for _, v in d.fold:GetChildren() do
					local skin = d.toClone[v].Name
					v.Name = not enabled and skin 
						or selected == skin and 'Default' 
						or skin == 'Default' and selected ~= weapon and d.toReal[selected] and `_econ.{skin:lower()}/^w^` 
						or skin
				end
			end
		end

		__handleMultiWeaponFolder'MuzzleFlashes'
	end
	
	return `Succesfuly {enabled and 'Enabled' or 'Disabled'} {BOTH and 'Both' or PROJ_THROW and 'Projectiles' or 'Skin'}`
end

-- // ViewModels

modulesCopy = vmModsOG and modules.ViewModels or vmModules:Clone()

vmModules.Name = 'OriginalViewModels'
modulesCopy.Parent = modules

vmModsOG = vmModsOG or vmModules

if not _G.ECON_VARS.OG_VMS then
	for _, v in skins:GetDescendants() do
		if v:IsA('Model') then
			local FINAL_TB = {
				model  = v;
				mod = vmModsOG:FindFirstChild(v.Name,true);
			}

			OG_VMS.fromName[v.Name] = FINAL_TB
			table.insert(OG_VMS.all, FINAL_TB)
		end
	end

	_G.ECON_VARS.OG_VMS = OG_VMS

	local _toWeapon = {
		BowChargeEffects = 'Bow';
		BurningEffects = 'Flamethrower';
		ChainsawParticles = 'Chainsaw';
		DeflectActiveEffects = 'Katana';
		DeflectHitEffects = 'Katana';
		FireHitboxes = 'Molotov';
		FlamethrowerAirblasts = 'Flamethrower';
		FlamethrowerFlames = 'Flamethrower';
		JumpPads = 'Jump Pad';
		FreezeEffects = 'Freeze Ray';
		MolotovExplosionEffects = 'Molotov';
		SmokeClouds = 'Smoke Grenade';
		WarHornEffects = 'War Horn';

		MuzzleFlashes = 'MuzzleFlashes';
		Projectiles = 'ProjectileOrThrowable';
		Throwables = 'ProjectileOrThrowable';
	}

	local __RET = {all={};fromWeapon={}}
	local function __clone(fold)
		local weapon = _toWeapon[fold.Name]
		if weapon then
			local _clones = {}
			local _toClone = {}
			local _toReal = {}
			for _, v in fold:GetChildren() do
				local cl = v:Clone();
				table.insert(_clones,cl);
				_toClone[v] = cl;
				_toReal[v.Name] = v;
			end

			__RET[fold] = {
				weapon = weapon; all = _clones; fromSkin = _toClone;
			}

			if not __RET.fromWeapon[weapon] then
				__RET.fromWeapon[weapon] = {}
			end

			table.insert(__RET.fromWeapon[weapon],{
				fold = fold; all = _clones; toClone = _toClone; toReal = _toReal;
			})
		end
	end

	for _, v in misc:GetChildren() do
		__clone(v)
	end

	__clone(throwables);
	__clone(projectiles);

	_G.ECON_VARS.OG_MISC = __RET
	OG_MISC = __RET
end

-- // UI

local UI_WINDOW = UTILS.ECON_UI:CreateWindow({
	Name = 'Econ',
	Icon = nil,
	LoadingTitle = '',
	LoadingSubtitle = "by ConePartyy",
	Theme = "AmberGlow", 

	DisableEconFieldPrompts = true,
	DisableBuildWarnings = true,

	ConfigurationSaving = {
		Enabled = true,
		FolderName = 'cone',
		FileName = "econ"
	},
})

-- // Wrap File Work

local SKINCHANGER_FILE = 'cSkinchanged'
local WRAPPER_FILE = 'cSkin'

local wrapSkinInfo = {}

function readSkinFile()
	local rf = isfile(WRAPPER_FILE)
	if rf then
		local splits = readfile(WRAPPER_FILE):split'ï¿½'
		for _, v in splits do
			local inf = v:split'`'
			wrapSkinInfo[inf[1]] = {
				wrap = inf[2],
				inverted = inf[3] == 'true'
			}
		end
	else
		writefile(WRAPPER_FILE, '')
	end
end

function writeSkinFile()
	local str = ''
	for skin, inf in wrapSkinInfo do
		str..=skin..'`'..(inf.wrap or 'None')..'`'..tostring(inf.inverted)..'ï¿½'
	end
	writefile(WRAPPER_FILE, str)
end

readSkinFile()

-- // Skinchanger File Work

local weaponToButton = {}
local charapb = {}

function readsfile()
	local rf = isfile(SKINCHANGER_FILE) 
	if rf then
		local splits = readfile(SKINCHANGER_FILE):split'ï¿½'
		for _, v in splits do
			local inf = v:split('`')
			if weaponToButton[inf[1]] then
				_G.toskin[inf[1]] = inf[2]
				weaponToButton[inf[1]]:Set({inf[2]}, true)
			elseif tonumber(inf[1]) and not inf[2] then
				CURRENT_ID = tonumber(inf[1])
				charapb:Set(CURRENT_ID)
			end
		end
	else
		writefile(SKINCHANGER_FILE, '')
	end
end

function writesfile()
	local str = `{CURRENT_ID}ï¿½`
	for weapon, skin in _G.toskin do
		str..=weapon..'`'..skin..'ï¿½'
	end
	writefile(SKINCHANGER_FILE, str)
end

-- // Main Events

if _G.hd then
	for _, v in _G.hd do
		v:Disconnect()
	end
end

local function __handleFighterInterface(ui)
	if ui.Name == plr.Name then
		local funcs = {}

		local items = ui.Items.Container

		funcs.handleSlot = function(v)
			local _selected = _G.toskin[v.Name]
			if _selected then
				local icon = v.Icon :: ImageLabel
				icon.ResampleMode = Enum.ResamplerMode[_selected:find('Pixel') and 'Pixelated' or 'Default'] 
				icon.Image = UTILS.SKIN_MOD.viewmodels[_selected].image
			end
		end

		-- //

		items.ChildAdded:Connect(funcs.handleSlot)
		for _, v in items:GetChildren() do
			funcs.handleSlot(v)
		end
	end
end

local function __removeSkins()
	for weapon, val in HANDLED_WEAPONS do
		if val then
			__updVMMod(weapon,false,1)
		end
	end
end

-- // Connections

_G.hd = {
	hs = hitmarkerSounds.ChildAdded:Connect(function(v : Sound)
		if v:IsA('Sound') and v.SoundId == module.headshotid then
			for _, v in _G.ECON_VARS.HEADSHOT_FUNCS do
				v()
			end
		end
	end);

	weaponReceiver = rep.Remotes.Replication.Fighter.Replicate.OnClientEvent:Connect(function(...)
		local args = {...}
		if typeof(args[4]) == 'table' then -- Player Data
			local _plr = args[4]["Â¸"]
			local _byteID = args[2]
			if _plr then -- Player Byte ID
				if _plr.Name == plr.Name then
					local _lastByteID = _G.ECON_VARS.OUR_BYTEID
					_G.ECON_VARS.OUR_BYTEID = _byteID

					if _byteID ~= _lastByteID and _G.ECON_VARS.BYTE_WEAPONS[plr.UserId] then
						table.clear(_G.ECON_VARS.BYTE_WEAPONS[plr.UserId])
					end
				end

				_G.ECON_VARS.RIVALS_BYTEPLR[_byteID] = players:FindFirstChild(_plr.Name).UserId
			elseif args[4]['Â·'] then -- Player Weapon Equipped
				local userId = _G.ECON_VARS.RIVALS_BYTEPLR[_byteID]
				local weaponData = args[4]['Â¶']

				if userId == plr.UserId then
					__updVMMod(weaponData.e,true)
				else
					__removeSkins()
				end

				if not _G.ECON_VARS.BYTE_WEAPONS[userId] then
					_G.ECON_VARS.BYTE_WEAPONS[userId] = {}
				elseif args[5] == 1 then
					table.clear(_G.ECON_VARS.BYTE_WEAPONS[userId])
				end

				_G.ECON_VARS.BYTE_WEAPONS[userId][weaponData['Â¾']] = weaponData.e
			end
		elseif args[3] == '' then -- Throwable / Projectile
			local _byteID = args[2]

			local userId = _G.ECON_VARS.RIVALS_BYTEPLR[_byteID]
			local isOurs = plr.UserId == userId
			
			local list = {
				[''] = 'Other';
				[''] = 'Projectile';
				['C'] = 'Throwable';
			}

			local _weapon = _G.ECON_VARS.BYTE_WEAPONS[userId][args[4]]
			local _isValidProjectile = list[_weapon == 'Slingshot' and args[6] or args[5]] and (typeof(args[6]) == 'Instance' or _weapon and table.find({'Slingshot'},_weapon))

			if not _weapon or not isOurs and _isValidProjectile then -- // If there's no weapon, data receiving has failed | [ When you load Econ in the middle of a match ]
				local function __removeWeapon(w)
					__updVMMod(w,false,true)
					--UTILS.ECON_UI:Notify({
					--	Title = 'Disable Projectiles',
					--	Content = __updVMMod(w,false,true),
					--	Duration = 3,
					--	Image = 'check'
					--})
				end
				
				if _weapon then
					if PROJ_THROW_ACTIVE[_weapon] then
						__removeWeapon(_weapon)
					end
				else
					for weapon, val in PROJ_THROW_ACTIVE do
						if val then
							__removeWeapon(weapon)
						end
					end
				end
				
				return
			end

			if _isValidProjectile and isOurs and not PROJ_THROW_ACTIVE[_weapon] then
				__updVMMod(_weapon,true,true)
				--UTILS.ECON_UI:Notify({
				--	Title = `Enable {_weapon}`,
				--	Content = __updVMMod(_weapon,true,true),
				--	Duration = 3,
				--	Image = 'check'
				--})
			end
		elseif args[5] == 'GameOver' then
			__removeSkins()
		end
	end); UI_Imgs = fighterInterfaces.ChildAdded:Connect(__handleFighterInterface)
}

-- // Wrapper

local function gt()
	local inf = wrapSkinInfo[string.split(cw.Name, ' - ')[3]]
	UTILS.WRAPPER_MOD:wrapThis(cw, (inf and inf.wrap or 'None'), (inf and inf.inverted), assets.ViewModels, assets.WrapTextures)
end

local function check(v)
	if v.Name:find(plr.Name) then
		cw = v
		gt()
	end
end

if vms:GetChildren()[1] then
	check(vms:GetChildren()[1])
end

-- // REST

local toskin = {}
_G.toskin = toskin

local initConnections = {}

-- // CHARACTER CHANGER

local loadedids = {}

local ltagcon = nil
local lll = nil

-- // Character Changer

local dn = (plr.DisplayName or plr.Name)..(plr.HasVerifiedBadge and ' '..utf8.char(0xE000) or '')
local usn = plr.Name

local function cchar(id)
	task.spawn(function()
		local id = typeof(id) == 'number' and id or CURRENT_ID
		if not id then return end

		local lid = loadedids[id]

		local suc, z = false, 'Lid Exists'
		if not (lid and lid.apr) then
			suc, z = pcall(function()
				return players:GetCharacterAppearanceAsync(id)
			end)
		end

		local cha = lid and lid.apr or suc and z

		if not cha then UTILS.ECON_UI:Notify({Title = 'CharacterAppearance Error', Content = tostring(z), Duration = 10, Image = 'search-x'}) return end

		local char = plr.Character

		-- // REST

		local inff = nil
		task.spawn(function()
			-- // VISUALS

			for _, v in ID_CHANGED_FUNCS do
				v()
			end

			local suc, z = false, 'Lid Exists'
			if not lid or not lid.inff then
				suc, z = pcall(function()
					return game:GetService('UserService'):GetUserInfosByUserIdsAsync({id})
				end)
			end

			local inf = lid and lid.inff or suc and z

			if not inf or typeof(inf) == 'boolean' then UTILS.ECON_UI:Notify({Title = 'Name,Displayname Error', Content = tostring(z), Duration = 10, Image = 'search-x'}) return end

			inff = inf
			loadedids[id].inff = inf

			if ltagcon then
				for _, v in pairs(ltagcon) do
					v:Disconnect()
				end
			end

			if lll then
				lll:Disconnect()
			end

			if inf and inf[1] then
				inf = inf[1]

				local root = char:WaitForChild('HumanoidRootPart')

				local function tagfunc(tag)
					if not tag or tag.Name ~= 'Nametag' then return end

					if ltagcon then
						for _, v in pairs(ltagcon) do
							v:Disconnect()
						end
					end

					local frame = tag.Frame or tag:WaitForChild('Frame')
					local ff = frame.Player
					local un = ff.Username

					local function hn()
						dn = (tostring(inf.DisplayName) or inf.Username)..(inf.HasVerifiedBadge and ' '..utf8.char(0xE000) or '')
						usn = inf.Username
						ff.Text = dn
						un.Text = inf.DisplayName and '@'..inf.Username or ''
					end

					hn()

					ltagcon = {}

					table.insert(ltagcon, ff:GetPropertyChangedSignal('Text'):Connect(hn))
					table.insert(ltagcon, tag:GetPropertyChangedSignal('Parent'):Once(function()
						for _, v in pairs(ltagcon) do
							v:Disconnect()
						end
					end))

					for _, v in pairs(ltagcon) do
						table.insert(initConnections, v)
					end
				end

				tagfunc(root:FindFirstChild('Nametag'))
				lll = root.ChildAdded:Connect(tagfunc)
				table.insert(initConnections, lll)
			end
		end)

		loadedids[id] = {
			apr = cha,
		}

		task.spawn(function()
			local suc, z = false, 'Lid Exists'
			if not (lid and lid.ap) then
				suc, z = pcall(function()
					return players:GetHumanoidDescriptionFromUserId(id)
				end)
			end

			local ap = lid and lid.ap or suc and z

			if not ap then UTILS.ECON_UI:Notify({Title = 'FaceDecal Error', Content = tostring(z), Duration = 10, Image = 'search-x'}) return end

			if not ap then
				ap = {
					Face = 0
				}
			end

			loadedids[id].ap = ap

			local face = ap.Face
			local faceid = "rbxthumb://type=Asset&w=768&h=432&id="..face

			local head = char:WaitForChild('Head')
			for _, v in pairs(head:GetChildren()) do
				if v.Name == 'face' then
					v:Destroy()
				end
			end

			local newface = Instance.new('Decal', head)
			newface.Name = 'face'
			newface.Texture = face ~= 0 and faceid or 'rbxasset://textures/face.png'
		end)

		local function caa(characterModel, accessory)
			task.spawn(function()
				local accessoryAttachment = accessory:FindFirstChildWhichIsA("Attachment", true)
				if not accessoryAttachment then
					warn("No attachments found in accessory. Accessory was not attached.")
					return
				end

				local attachmentName = accessoryAttachment.Name
				local attachTo = nil

				local st = tick()
				repeat run.Stepped:Wait() attachTo = characterModel:FindFirstChild(attachmentName, true) until attachTo

				if not attachTo or not attachTo:IsA("Attachment") then
					warn(string.format("No attachment named %s found in character. Accessory was not attached.", attachmentName))
					return
				end

				local Handle = accessory:FindFirstChild("Handle")
				if not Handle then
					warn("Attachment has no handle. Accessory was not attached.")
					return
				end

				Handle.CFrame = attachTo.WorldCFrame * accessoryAttachment.CFrame:Inverse()

				local nc = Instance.new('WeldConstraint', Handle)
				nc.Part0 = Handle
				nc.Part1 = attachTo.Parent

				accessory.Parent = characterModel
			end)
		end

		local names = {'Shirt', 'Pants', 'ShirtGraphic', 'Accessory'}

		local function hand(v)
			if table.find(names, v.ClassName) then
				task.defer(function()
					v:Destroy()
				end)
			elseif v.ClassName == 'BodyColors' then
				local bc = cha:FindFirstChild('Body Colors') :: BodyColors
				if bc then
					v.HeadColor3 = bc.HeadColor3
					v.TorsoColor3 = bc.TorsoColor3
					v.LeftArmColor3 = bc.LeftArmColor3
					v.LeftLegColor3 = bc.LeftLegColor3
					v.RightArmColor3 = bc.RightArmColor3
					v.RightLegColor3 = bc.RightLegColor3

					local to = {
						RightUpperArm = bc.RightArmColor3,
						RightLowerArm = bc.RightArmColor3,
						RightHand = bc.RightArmColor3,

						LeftUpperArm = bc.LeftArmColor3,
						LeftLowerArm = bc.LeftArmColor3,
						LeftHand = bc.LeftArmColor3,

						Head = bc.HeadColor3,
						UpperTorso = bc.TorsoColor3,
						LowerTorso = bc.TorsoColor3,

						RightUpperLeg = bc.RightLegColor3,
						RightLowerLeg = bc.RightLegColor3,
						RightFoot = bc.RightLegColor3,

						LeftUpperLeg = bc.LeftLegColor3,
						LeftLowerLeg = bc.LeftLegColor3,
						LeftFoot = bc.LeftLegColor3,
					}

					for piece, colr in pairs(to) do
						task.spawn(function()
							char:WaitForChild(piece).Color = colr
						end)
					end
				end
			end
		end

		for _, v : BodyColors in pairs(char:GetChildren()) do
			hand(v)
		end

		local con2
		local con = char.ChildAdded:Connect(function(v)
			if not table.find(_G.ECON_VARS.CHAR_UGC, v) then
				hand(v)
			end
		end)

		table.insert(initConnections, con)
		table.insert(initConnections, char:GetPropertyChangedSignal('Parent'):Once(function()
			if con then
				con:Disconnect()
			end

			if con2 then
				con2:Disconnect()
			end
		end))

		local function h2(v)
			if table.find(names, v.ClassName) then
				if v:IsA('Accessory') then
					local v = v:Clone()
					for _, v in v:GetChildren() do
						if v:IsA('BasePart') then
							v.CanCollide = false
							v.CanQuery = false
							v.CanTouch = false
							v.CollisionGroup = 'Players'
							v.Massless = true
						end
					end

					table.insert(_G.ECON_VARS.CHAR_UGC, v)
					caa(char, v)
				else 
					local cl = v:Clone() :: BodyColors
					table.insert(_G.ECON_VARS.CHAR_UGC, cl)
					cl.Parent = char
				end
			end
		end

		for _, v in pairs(cha:GetChildren()) do
			h2(v)
		end

		con2 = cha.ChildAdded:Connect(h2)
		table.insert(initConnections, con2)
	end)
end

-- // REST

local READ_FILE = false

for t, weapons in UTILS.WEAPON_TYPES.typeToWeapons do
	local gameplayTab = UI_WINDOW:CreateTab(WEAPON_TYPES[t])

	if t == 1 then
		local sec = gameplayTab:CreateSection'Character Changer'

		local charchanger = gameplayTab:CreateInput({
			Name = 'Player ID / Name',
			CurrentValue = tostring(CURRENT_ID),
			PlaceholderText = 'ConePartyy',
			RemoveTextAfterFocusLost = false,
			Flag = 'appearancechangerid',
			Callback = function(t)
				local suc, z = false, 'Lid Exists'
				if not (tonumber(t) or tonumber(_G.ECON_VARS.NAME_ID[t])) then
					suc, z = pcall(function()
						return players:GetUserIdFromNameAsync(t)
					end)
				end

				local id = tonumber(t) or tonumber(_G.ECON_VARS.NAME_ID[t] or suc and z)

				if not id then UTILS.ECON_UI:Notify({Title = 'Name>ID Error', Content = tostring(z), Duration = 10, Image = 'search-x'}) return end

				if id then
					_G.ECON_VARS.NAME_ID[t] = id
					CURRENT_ID = id
					cchar(id)

					if READ_FILE then
						writesfile()
					end
				end
			end,
		})

		charapb = charchanger

		local visualSection = gameplayTab:CreateSection('Wrap Changer - Hold a weapon')

		local selectedWrap = 'None'
		local selectedWeapon = 'Assault Rifle'
		local wrapsX = {'None'}
		local inverted = false

		for wrap, v in UTILS.WRAPPER_MOD:getAll() do
			table.insert(wrapsX, wrap)
		end

		function updateSkin()
			local name = string.split(cw.Name, ' - ')[3]
			wrapSkinInfo[name] = {
				wrap = selectedWrap,
				inverted = inverted,
			}

			writeSkinFile()
			gt()
		end

		local typeWrap
		local wrapDropdown = gameplayTab:CreateDropdown({
			Name = 'Wrap',
			Options = wrapsX,
			CurrentOption = {selectedWrap},
			MultipleOptions = false,
			Ext = true,
			Flag = 'wcwcdropdown',
			Callback = function(Options, nosound)
				selectedWrap = Options[1]

				if not nosound and not (not vms or #vms:GetChildren() == 0) then
					updateSkin()
				elseif not nosound then
					UTILS.ECON_UI:Notify({
						Title = 'Error',
						Content = 'Hold a weapon to change your wrap', 
						Image = 6026568210,
						Duration = 2,
					})
				end
			end,
		})

		local wrapz = {'none'}
		for wrap, v in UTILS.WRAPPER_MOD:getAll() do
			table.insert(wrapz, wrap:lower())
		end

		typeWrap = gameplayTab:CreateInput({
			Name = 'Type Wrap',
			CurrentValue = selectedWrap,
			PlaceholderText = selectedWrap,
			RemoveTextAfterFocusLost = true,
			Ext = true,
			Flag = 'wcwcinput',
			Callback = function(txt, nosound)
				if table.find(wrapz, txt:lower()) then
					local realWrap = 'None'
					for w, v in UTILS.WRAPPER_MOD:getAll() do
						if w:lower() == txt:lower() then
							realWrap = w
						end
					end

					if not (not vms or #vms:GetChildren() == 0) then
						wrapDropdown:Set({realWrap}, nosound)
					end

					selectedWrap = realWrap

					if not nosound and not (not vms or #vms:GetChildren() == 0) then
					elseif not nosound then
						UTILS.ECON_UI:Notify({
							Title = 'Error',
							Content = 'Hold a weapon to change your wrap', 
							Image = 6026568210,
							Duration = 2,
						})
					end
				end
			end,
		})

		local invertedToggle = gameplayTab:CreateToggle({
			Name = 'Inverted',
			CurrentValue = false,
			Ext = true,
			Flag = "invtoggle",
			Callback = function(Value, nosound)
				inverted = Value

				if not nosound and not (not vms or #vms:GetChildren() == 0) then
					updateSkin()
				elseif not nosound then
					UTILS.ECON_UI:Notify({
						Title = 'Error',
						Content = 'Hold a weapon to change your wrap', 
						Image = 6026568210,
						Duration = 2,
					})
				end
			end,
		})

		local function _vmAdded(v)
			check(v)

			if not v:HasTag('Changed') and v.Name:find(plr.Name) then
				for _, v in _G.toskin do
					_G.ac(v)
				end
			end
		end

		table.insert(initConnections, vms.ChildAdded:Connect(function(v)
			_vmAdded(v)

			local n = string.split(cw.Name, ' - ')[3]
			local inf = wrapSkinInfo[n]
			visualSection:Set(n and 'Wrap Changer - '..n or 'Wrap Changer - Hold a weapon')
			task.spawn(function()
				typeWrap:Set(inf and inf.wrap or 'None', 1)
			end)

			task.spawn(function()
				invertedToggle:Set(inf and inf.inverted, 1)	
			end)
		end))

		table.insert(initConnections, tempvms.ChildAdded:Connect(_vmAdded))

		table.insert(initConnections, vms.ChildRemoved:Connect(function(v)
			if not vms or #vms:GetChildren() == 0 then
				visualSection:Set('Wrap Changer - Hold a weapon')
				task.spawn(function()
					typeWrap:Set('None', 1)
				end)

				task.spawn(function()
					invertedToggle:Set(false, 1)	
				end)
			end
		end))

		local function frcheck()
			local v = vms:GetChildren()[1]
			if v then
				check(v)

				local n = string.split(cw.Name, ' - ')[3]
				local inf = wrapSkinInfo[n]
				visualSection:Set(n and 'Wrap Changer - '..n or 'Wrap Changer - Hold a weapon')
				task.spawn(function()
					typeWrap:Set(inf and inf.wrap or 'None', 1)
				end)

				task.spawn(function()
					invertedToggle:Set(inf and inf.inverted, 1)	
				end)
			end
		end

		_G.frr = frcheck
	end

	local visualSection = gameplayTab:CreateSection'Weapons'

	for skin, v in weapons do
		skin = v
		v = UTILS.SKIN_INFO.skinInfo[v]

		if v then
			local ov = table.clone(v)
			v = {'Dont Change'}
			for _, v2 in pairs(ov) do
				table.insert(v, v2)
			end

			local selectedSkin = [[Dont Change]]
			local drop = gameplayTab:CreateDropdown({
				Name = skin,
				Options = v,
				CurrentOption = {[[Dont Change]]},
				MultipleOptions = false,
				Flag = skin,
				Callback = function(Options, nosound, nowrite)
					selectedSkin = Options[1]

					_G.toskin[skin] = Options[1]

					if _G.ac then
						_G.ac(selectedSkin)
					else
						local skins = ov
						table.insert(skins,skin)
					end

					if not nosound then
						if READ_FILE then
							writesfile()
						end
					end
				end,
			})

			weaponToButton[skin] = drop
		end
	end
end

local going = true

plr:SetAttribute('OriginalPositionb', nil)
plr:SetAttribute('OriginalPositionb', true)

table.insert(initConnections, plr:GetAttributeChangedSignal('OriginalPositionb'):Connect(function()
	for _, v in initConnections do
		v:Disconnect()
	end

	going = false
	return
end))

local relAnim = rep.Modules.AnimationLibrary

local soundGroup = ss:FindFirstChild('Zero') or Instance.new('SoundGroup', ss)
local animStorage = uis:FindFirstChild('AnimsEcon') or Instance.new('Folder', uis)
animStorage.Name = 'AnimsEcon'
soundGroup.Name = 'Zero'

local soundOn = true

-- // Global

if _G.soundCon then
	_G.soundCon:Disconnect()
end

if _G.volumeC then
	_G.volumeC:Disconnect()
end

_G.volumeC = ss.Other:GetPropertyChangedSignal('Volume'):Connect(function()
	if soundOn then
		soundGroup.Volume = ss.Other.Volume
	end
end)

_G.soundCon = weaponSounds.ChildAdded:Connect(function(s)
	if (not table.find(module.canPlay, s.SoundId) or s.PlaybackSpeed == .5) and not s:HasTag('IsOurs') then
		s.SoundGroup = soundGroup
	end
end)

-- // Main

local toMuzzle = {
	Minigun = 'Minigun',
	Spray = 'Spray',
}

for _, v in skins.Weapons:GetChildren() do
	toMuzzle[v.Name] = toMuzzle[v.Name] or 'Default'
end

task.spawn(function()
	local prelo = {}
	for _, v in _G.toskin do
		table.insert(prelo, UTILS.SKIN_MOD.viewmodels[v].image)
	end
	game:GetService('ContentProvider'):PreloadAsync(prelo)
end)

function findSkin(name)
	local skins = OG_VMS.fromName
	for n, v in skins do
		if n == name then return v.model end
	end
end

-- // Weapons ViewProfile UI Changer

local prcons = {}
local pacons = {}
local pa2cons = {}
local sidecons = {}

local is = _G.selectChanged

function getIcon()
	local content = nil
	local isReady = nil
	local id = CURRENT_ID or plr.UserId
	local s = _G.ECON_VARS.SAVED_ICONS[id]

	if s then
		content = s.content
		isReady = s.isReady
	else
		local suc, c, r = pcall(function()
			return players:GetUserThumbnailAsync(id, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420)
		end)

		if not suc or not r then UTILS.ECON_UI:Notify({Title = 'PlrIcon Error', Content = tostring(c), Duration = 10, Image = 'search-x'}) return end

		content = c
		r = r

		_G.ECON_VARS.SAVED_ICONS[id] = {
			content = c, isReady = r
		}
	end

	return content, isReady
end

-- // FUNCTIONS

function idtplr(id)
	local d = _G.ECON_VARS.ID_PLR[id]
	if d then return d end

	for _, v in players:GetPlayers() do
		if v.UserId == id then
			_G.ECON_VARS.ID_PLR[id] = v
			return v
		end
	end
end

-- // Weapons List UI

for _, v in fighterInterfaces:GetChildren() do
	__handleFighterInterface(v)
end

-- // Character UI

task.spawn(function()
	local MAIN_UI = plr.PlayerGui:WaitForChild('MainGui')
	local pages = MAIN_UI.MainFrame.Pages

	local function checkfor(v)
		if v.Name == 'ViewProfile' then
			if prcons then
				for _, v in pairs(prcons) do
					v:Disconnect()
				end
			end

			local _active = v:WaitForChild('Active')
			local __player = _active.Player

			local _display = __player.DisplayName
			local _username = __player.Username
			local _headshot = __player.Headshot
			local list = __player.FavoriteWeapons

			local content, isReady = getIcon()

			if not _G.ECON_VARS.PLR_ICONS[_headshot] then
				_G.ECON_VARS.PLR_ICONS[_headshot] = _headshot.Image
			end

			local function hn(changedim)
				if string.find(_G.ECON_VARS.PLR_ICONS[_headshot], tostring(plr.UserId)) then
					_display.Text = dn
					_username.Text = '@'..usn
					if isReady and _headshot.Image ~= content then
						_G.ignorenext = true
						_headshot.Image = content
					end
				else
					local str = string.sub(_G.ECON_VARS.PLR_ICONS[_headshot], 56, -1)
					local id = tonumber(string.sub(str, 1, string.find(str, '&')-1))
					if id and idtplr(id) then
						_username.Text = '@'..idtplr(id).Name
					end
				end
			end

			prcons = {}

			if not is then
				local function handle(v)
					task.spawn(function()
						local b = v.Name == 'PickWeaponSlot' and v:WaitForChild('Button')
						if b and b:FindFirstChild('Icon') and b.Icon:FindFirstChild('Picture') then
							b = b.Icon.Picture
							b.Name = 'OPic'

							local function calc()
								if string.find(_G.ECON_VARS.PLR_ICONS[_headshot], tostring(plr.UserId)) then
									local ts = UTILS.SKIN_MOD.its[b.Image]
									local tog = UTILS.SKIN_INFO.skinToOg[ts] or ts
									local tocur = _G.toskin[tog]
									if tocur and tocur ~= 'Dont Change' then
										b.Image = UTILS.SKIN_MOD.viewmodels[tocur].image
									end
								end
							end

							table.insert(ID_CHANGED_FUNCS, calc)
							calc()

							local z = b:GetPropertyChangedSignal('Image'):Connect(calc)
							table.insert(prcons, z)
							table.insert(initConnections, z)
						end
					end)
				end

				for _, v in pairs(list:GetChildren()) do
					handle(v)
				end

				table.insert(prcons, list.ChildAdded:Connect(handle))
			end

			hn()

			table.insert(ID_CHANGED_FUNCS, hn)
			table.insert(prcons, _headshot:GetPropertyChangedSignal('Image'):Connect(function()
				if not _G.ignorenext then
					_G.ECON_VARS.PLR_ICONS[_headshot] = _headshot.Image
				else
					_G.ignorenext = false
				end

				hn(true)
			end))

			table.insert(prcons, _username:GetPropertyChangedSignal('Text'):Connect(function()
				hn(true)
			end))

			table.insert(prcons, _display:GetPropertyChangedSignal('Text'):Connect(function()
				hn(true)
			end))

			for _, v in pairs(prcons) do
				table.insert(initConnections, v)
			end 
		end
	end

	if pages:FindFirstChild('ViewProfile') then
		checkfor(pages.ViewProfile)
	end

	table.insert(initConnections, pages.ChildAdded:Connect(checkfor))

	-- // Lobby Icon Party #1

	local lobby = MAIN_UI.MainFrame.Lobby

	if pacons then
		for _, v in pairs(pacons) do
			v:Disconnect()
		end
	end

	pacons = {}

	local function cf(v)
		if v.Name == 'Party' then
			local bd = v.BottomDisplay
			local con = bd.Container

			local function h(v : Frame)
				if v.Name == 'PartyMemberSlot' and v.LayoutOrder == 1 then
					local ico = v.Button.Icon
					ico.Image = getIcon()

					table.insert(ID_CHANGED_FUNCS, function()
						ico.Image = getIcon()
					end)

					local z = ico:GetPropertyChangedSignal('Image'):Connect(function()
						ico.Image = getIcon()
					end)

					table.insert(pacons, z)
					table.insert(initConnections, z)
				end
			end


			local z = con.ChildAdded:Connect(h)
			table.insert(pacons, z)
			table.insert(initConnections, z)

			for _, v in pairs(con:GetChildren()) do
				h(v)
			end
		end
	end

	if lobby:FindFirstChild('Party') then
		cf(lobby.Party)
	end

	table.insert(initConnections, lobby.ChildAdded:Connect(cf))

	-- // Lobby Icon Party #2

	if pa2cons then
		for _, v in pairs(pa2cons) do
			v:Disconnect()
		end
	end

	pa2cons = {}

	local function cc(v)
		if v.Name == 'Party' then
			local b = v.Members

			local function h(v : Frame)
				if v.Name == 'PartyMemberBigSlot' and v.LayoutOrder == 1 then
					local ico = v.Icon
					ico.Image = getIcon()

					local _display = v.DisplayName
					local _username = v.Username

					local function hn()
						_display.Text = dn
						_username.Text = '@'..usn
						ico.Image = getIcon()
					end

					local function add(con)
						table.insert(pa2cons, con)
						table.insert(initConnections, con)
					end

					hn()
					add(_username:GetPropertyChangedSignal('Text'):Connect(hn))
					add(_display:GetPropertyChangedSignal('Text'):Connect(hn))
					add(ico:GetPropertyChangedSignal('Image'):Connect(hn))

					table.insert(ID_CHANGED_FUNCS, hn)
				end
			end

			local z = b.ChildAdded:Connect(h)
			table.insert(pa2cons, z)
			table.insert(initConnections, z)

			for _, v in pairs(b:GetChildren()) do
				h(v)
			end
		end
	end

	if pages:FindFirstChild('Party') then
		cc(pages.Party)
	end

	table.insert(initConnections, pages.ChildAdded:Connect(cc))

	-- // Side Party

	local lobby = MAIN_UI.MainFrame.Lobby

	if sidecons then
		for _, v in pairs(sidecons) do
			v:Disconnect()
		end
	end

	sidecons = {}

	local function h(v)
		if v.Name == 'SideParty' then
			local con = v.Container

			local function h(v : Frame)
				if v.Name == 'PartyMemberSlot' and v.LayoutOrder == -1 then
					local ico = v.Button.Icon
					ico.Image = getIcon()

					table.insert(ID_CHANGED_FUNCS, function()
						ico.Image = getIcon()
					end)

					local function add(con)
						table.insert(sidecons, con)
						table.insert(initConnections, con)
					end

					add(ico:GetPropertyChangedSignal('Image'):Connect(function()
						ico.Image = getIcon()
					end))
				end
			end

			local z = con.ChildAdded:Connect(h)
			table.insert(sidecons, z)
			table.insert(initConnections, z)

			for _, v in pairs(con:GetChildren()) do
				h(v)
			end
		end
	end

	if pages:FindFirstChild('SideParty') then
		h(pages.SideParty)
	end

	table.insert(initConnections, pages.ChildAdded:Connect(h))
end)

-- // Weapons UI

if not _G.selectChanged then
	task.spawn(function()
		local MAIN_UI = plr.PlayerGui:WaitForChild('MainGui').MainFrame.Equipment.Weapons.Container.List.Container

		local function handle(v)
			local b = v:FindFirstChild('Button')
			b = b and b:FindFirstChild('Icon')

			local xico = b and b:FindFirstChild('UICorner')
			local n = v.Name == 'EquipmentWeaponSlot'
			if n and b and not xico then
				local function calc()
					local ts = UTILS.SKIN_MOD.its[b.Image]
					local tog = UTILS.SKIN_INFO.skinToOg[ts] or ts
					local tocur = _G.toskin[tog]
					if tocur and tocur ~= 'Dont Change' then
						b.Image = UTILS.SKIN_MOD.viewmodels[tocur].image
					end
				end

				calc()
				b:GetPropertyChangedSignal('Image'):Connect(calc)
			elseif n and b and xico then

			end
		end

		for _, v in MAIN_UI:GetChildren() do
			handle(v)
		end

		MAIN_UI.ChildAdded:Connect(handle)
	end)
end

-- // Weapon Selection UI

if not _G.selectChanged then
	task.spawn(function()
		local function checkfor(v)
			task.spawn(function()
				local typ = v.Name == 'PickWeapons' and 1 or v.Name == 'PickWeaponsList' and 2 or 0
				if typ>0 and not v:HasTag('Econ') then
					local chosen = v:WaitForChild('ChosenWeapons')
					local list = typ == 1 and v:WaitForChild('List') or v:WaitForChild('ListContainer').List

					v:AddTag'Econ'

					local cons = {}

					if chosen and list then
						list = list.Container

						-- // LIST

						local function handle(v)
							task.spawn(function()
								local b = v.Name:find('PickWeapon') and v:WaitForChild('Button')
								if b and b:FindFirstChild('Icon') and b.Icon:FindFirstChild('Picture') then
									b = b.Icon.Picture
									b.Name = 'OPic'

									local function calc()
										local ts = UTILS.SKIN_MOD.its[b.Image]
										local tog = UTILS.SKIN_INFO.skinToOg[ts] or ts
										local tocur = _G.toskin[tog]
										if tocur and tocur ~= 'Dont Change' then
											b.Image = UTILS.SKIN_MOD.viewmodels[tocur].image
										end
									end

									calc()
									table.insert(cons, b:GetPropertyChangedSignal('Image'):Connect(calc))
								end
							end)
						end

						for _, v in pairs(list:GetChildren()) do
							handle(v)
						end

						local con = list.ChildAdded:Connect(handle)
						table.insert(cons, con)

						-- // MAIN SELECTION

						local function handle2(v)
							task.spawn(function()
								if v.Name:find('ChosenSlot') then
									local b = v.Button.Picture
									local function calc()
										local ts = UTILS.SKIN_MOD.its[b.Image]
										local tog = UTILS.SKIN_INFO.skinToOg[ts] or ts
										local tocur = _G.toskin[tog]
										if tocur and tocur ~= 'Dont Change' then
											b.Image = UTILS.SKIN_MOD.viewmodels[tocur].image
										end
									end

									calc()
									table.insert(cons, b:GetPropertyChangedSignal('Image'):Connect(calc))
								end
							end)
						end

						for _, v in pairs(chosen:GetChildren()) do
							handle2(v)
						end

						table.insert(cons, chosen.ChildAdded:Connect(handle2))

						-- // FINISH

						--for _, v in pairs(cons) do
						--	table.insert(initConnections, v)
						--end
					end
				end
			end)
		end

		local MAIN_UI = plr.PlayerGui:WaitForChild('MainGui')
		local pages = MAIN_UI.MainFrame.Pages

		if pages:FindFirstChild('PickWeapons') then
			checkfor(pages.PickWeapons)
		end

		pages.ChildAdded:Connect(checkfor)
		--table.insert(initConnections, pages.ChildAdded:Connect(checkfor))
	end)
end

_G.selectChanged = true

-- // Rest

function special(name)
	if name then 
		local keywords = {'sprint', 'idle', 'reload'}
		for _, v in keywords do
			if name:find(v) then
				return true
			end
		end
	end
end

function applySkin(skinName, cs)
	task.spawn(function()
		if skinName == 'Dont Change' then return end
		if not UTILS.SKIN_INFO.skinToOg[skinName] then skinName = UTILS.SKIN_INFO.lowerToOg[skinName:lower()] end

		local ogitem = UTILS.SKIN_INFO.skinToOg[skinName]
		if not ogitem then return end

		local char = plr.Character		
		local hum = char and char:FindFirstChild('Humanoid') :: Humanoid

		-- // Main Changer

		local function apl(vm)
			task.spawn(function()
				local skin = findSkin(skinName)
				local vm = vm or vms:GetChildren()[1]

				if skin and not vm:HasTag'Changed' then
					vm:AddTag'Changed'

					-- // ANIMATIONS | CLEANI

					local last = vm.Name
					local spl = string.split(vm.Name, ' - ')
					local ogWeapon = skins:FindFirstChild(spl[2], true)

					if not vm:GetAttribute('OGItem') then
						vm:SetAttribute('OGItem', spl[2])
					end

					local ig = vm:GetAttribute('OGItem')

					vm.Name = spl[1]..' - '..spl[2].. ' - '..skinName

					local name = vm.name

					local clean = _G.ECON_VARS.VMS_CONS[name] or _G.ECON_VARS.VMS_CONS[last]
					if clean then
						for _, v in clean do
							v:Disconnect()
						end
					end

					-- // ANIMATIONS TABLE

					local econAnim = vm:FindFirstChild('Anims') or Instance.new('Folder', vm)
					econAnim:ClearAllChildren()
					econAnim.Name = 'Anims'

					local animator = vm.AnimationController.Animator :: Animator

					local animtbl = {}
					local toname = {}
					local prs = {}

					local sn = _G.ECON_VARS.ECON_ANIMS[name] or _G.ECON_VARS.ECON_ANIMS[last]
					if sn then
						for _, v in sn do
							if v.anim then
								v.anim:Stop(0)
							end
						end
					end

					local was = {}
					for _, v in vm.ItemVisual:GetChildren() do
						if v:HasTag('IsChanged') then
							table.insert(was, v)
						end
					end

					local dontDestroy = {'_katana'}

					local function destroyBlacklist(str)
						local IN_TABLE = false
						for _ , v in dontDestroy do
							if str:find(v) then
								IN_TABLE = true
							end
						end
						return IN_TABLE
					end

					-- // AnimationPlayed

					local apev = {}
					local playcons = {}
					function apev:Connect(func)
						table.insert(playcons, func)
					end

					-- // AnimationStopped

					local asev = {}
					local stopcons = {}
					function asev:Connect(func)
						table.insert(stopcons, func)
					end

					-- // Equiped

					local eqev = {}
					local equipcons = {}
					function eqev:Connect(func)
						table.insert(equipcons, func)
					end

					-- // Table

					local inz = {}
					local tb = {
						_destroyed = false,
						AnimationPlayed = apev,
						AnimationStopped = asev,
						Equipped = eqev,
					}

					function tb:_RegisterAmmoVisual()

					end

					local playii = {}
					function tb:IsAnimationPlaying(n)
						return table.find(playii, n)
					end

					-- // ANIMATIONS

					local _precontr = {
						anims = {}
					}

					function _precontr:add(pre, b)
						local x = {tbl = b}

						function x:stop()
							b.anim:Stop()
						end

						function x:play(args)
							args = args or {}

							local ref = args.reference :: AnimationTrack
							if ref and not ref.IsPlaying then return end

							if not special(b.name) and not args.isSpecial then
								for _, v : AnimationTrack in pairs(animator:GetPlayingAnimationTracks()) do
									if table.find(_G.ECON_VARS.ECON_ANIMS, v) and not special(toname[v.Animation.AnimationId]) then
										v:Stop()
									end
								end
							end

							local loaded = b.anim
							loaded.Priority = args.priority or prs[loaded] or Enum.AnimationPriority.Action2
							loaded.TimePosition = args.pos or 0			
							loaded:Play()
							loaded:AdjustWeight(1)
							loaded:AdjustSpeed(b.relinfo.Speed)

							-- // Connections

							task.spawn(function()
								local basicPlayed = ANIM_TO_NAME[b.prename] or b.prename

								table.insert(playii, basicPlayed)

								for _, v in playcons do
									v(basicPlayed)
								end

								table.insert(initConnections, loaded.Stopped:Once(function()
									table.remove(playii, table.find(playii, basicPlayed))
									for _, v in stopcons do
										v(basicPlayed)
									end
								end))
							end)

							-- // Rest

							local norm = loaded.Speed
							prs[loaded] = loaded.Priority

							-- // SOUNDS

							if b then
								if args.silenceReference and ref then
									table.insert(_G.silenced, ref)
								end

								if b.soundcall then
									task.spawn(b.soundcall,UTILS.RIVALS_UTILS, b.name, loaded.Speed, loaded, vm)
								end

								-- // REST

								if ref then
									table.insert(_G.ECON_VARS.VMS_CONS[name], ref.Stopped:Once(function()
										if args.unsilenceAfter then
											table.remove(_G.silenced, table.find(_G.silenced, ref))
										end

										loaded:Stop()
									end))
								end

								local function upd()
									local no = {'Water', 'Air'}
									if b.name:find'sprint' then
										loaded:AdjustSpeed(table.find(no, hum.FloorMaterial.Name) and .15 or norm)
									end
								end

								if args.stopref and ref then
									ref.Priority = Enum.AnimationPriority.Core
									ref:AdjustSpeed(0)
									ref:AdjustWeight(.001, 0)
								end

								if b.name:find'sprint' and hum then
									local con = hum:GetPropertyChangedSignal('FloorMaterial'):Connect(upd)
									upd()

									table.insert(_G.ECON_VARS.VMS_CONS[name], con)

									loaded.Stopped:Once(function()
										con:Disconnect()
									end)
								end
							end
						end

						_precontr.anims[pre] = x
					end

					-- // REST

					local _ogidtoinf = {}
					local _ogprentoid = {}

					for prename, name in UTILS.SKIN_MOD.viewmodels[ig].anims do
						local vmi = UTILS.SKIN_MOD.viewmodels[ig]

						local id = _G.animLib.Info[name].AnimationID
						local animType = vmi.animsReverse[name]

						_ogprentoid[prename] = id

						_ogidtoinf[id] = {
							name = name,
							prename = prename,
						}

						local new = UTILS.SKIN_MOD.viewmodels[skinName]
						local typeToReal = new.anims[animType]

						local nowid = _G.animLib.Info[typeToReal]

						if nowid then
							table.insert(inz, prename)

							local SOUND_CODE = UTILS.SKIN_SOUND_CODE[typeToReal]
							local SOUND_MOD = SOUND_CODE and loadstring(SOUND_CODE)

							local LOADED_ANIM = Instance.new('Animation') :: AnimationTrack
							LOADED_ANIM.AnimationId = nowid.AnimationID
							LOADED_ANIM.Parent = econAnim
							LOADED_ANIM = animator:LoadAnimation(LOADED_ANIM)

							table.insert(_G.ECON_VARS.ECON_ANIMS, LOADED_ANIM)

							toname[nowid.AnimationID] = name

							animtbl[id] = {
								anim = LOADED_ANIM,
								name = typeToReal,
								prename = prename,
								type = animType,
								relinfo = nowid,
								soundcall = SOUND_MOD and SOUND_MOD()
							}

							_precontr:add(prename, animtbl[id])
						end
					end

					for prename, name in UTILS.SKIN_MOD.viewmodels[skinName].anims do
						if not table.find(inz, prename) then
							local nowid = _G.animLib.Info[name]

							if nowid.AnimationID then
								local SOUND_CODE = UTILS.SKIN_SOUND_CODE[name]
								local SOUND_MOD = SOUND_CODE and loadstring(SOUND_CODE)

								local LOADED_ANIM = Instance.new('Animation') :: AnimationTrack
								LOADED_ANIM.AnimationId = nowid.AnimationID
								LOADED_ANIM.Parent = econAnim
								LOADED_ANIM = animator:LoadAnimation(LOADED_ANIM)

								table.insert(_G.ECON_VARS.ECON_ANIMS, LOADED_ANIM)

								toname[nowid.AnimationID] = name

								_precontr:add(prename, {
									anim = LOADED_ANIM,
									name = prename,
									prename = prename,
									type = prename,
									relinfo = nowid,
									soundcall = SOUND_MOD and SOUND_MOD()
								})
							end
						end
					end

					-- // Knife Backstab

					local h = _precontr.anims.HeavyAttackAnimationHit
					if h then
						table.insert(_G.ECON_VARS.HEADSHOT_FUNCS, function()
							if vms:GetChildren()[1] == vm then
								h:play({
									reference = _precontr.anims.HeavyAttack1.tbl.anim,
									isSpecial = 1,
									silenceReference = 1,
									unsilenceAfter = 1,
								})
							end
						end)
					end

					-- // Rest

					local playing = {}

					local function ct(track : AnimationTrack)
						if not table.find(_G.ECON_VARS.ECON_ANIMS, track) then
							local pr = track.Priority
							track:AdjustWeight(0.0001, 0)
							track:AdjustSpeed(0)
							track.Priority = Enum.AnimationPriority.Core

							local bg = _ogidtoinf[track.Animation.AnimationId]
							local b = animtbl[track.Animation.AnimationId]

							local z

							if bg and bg.prename == 'rareinspect' then
								z = _precontr.anims.inspect
							end

							local ri = _precontr.anims.rareinspect
							local inspects = {'inspect', 'rareinspect'}
							local rare = false
							if ri and math.random(1, (_G.rarechance or 6)) == 1 and table.find(inspects, bg.prename) then
								z = _precontr.anims.inspect
								rare = true

								local s = 1 + 0.25*math.random()
								UTILS.RIVALS_UTILS:CreateSound('rbxassetid://13159969353', .25, s, nil, true)
							end

							if b or z then
								local z = z or _precontr.anims[b.prename]
								if z then
									local tbl = {
										pos = track.TimePosition,
										priority = prs[z.tbl.anim] or pr,
										reference = track
									}

									if ri and rare then
										ri:play({
											reference = track,
											isSpecial = 1,
											priority = tbl.priority,
										})
									else
										z:play(tbl)
									end
								end
							end
						end
					end

					table.insert(_G.ECON_VARS.APPLIED_VMS, vm)

					local function pt(p)
						local c = vms:GetChildren()[1]

						if p ~= vms then
							for _, v in weaponSounds:GetChildren() do
								if (not v:GetAttribute('DontClearSound') and _G.soundToWeapon[v] == vm) then
									v:Destroy()
								end
							end
						end

						if not c or c == vm or not table.find(_G.ECON_VARS.APPLIED_VMS, c) then
							soundOn = p ~= vms
							soundGroup.Volume = soundOn and ss.Other.Volume or 0

							for _, v in equipcons do
								v()
							end

							if soundOn then
								for _, v in animtbl do
									v.anim:Stop()
								end
							end
						end
					end

					_G.ECON_VARS.VMS_CONS[name] = {}
					_G.ECON_VARS.VMS_CONS[name][1] = animator.AnimationPlayed:Connect(ct)
					for _, v in animator:GetPlayingAnimationTracks() do
						ct(v)
					end

					_G.ECON_VARS.VMS_CONS[name][3] = vm:GetPropertyChangedSignal('Parent'):Connect(function()
						if not vm.Parent then
							tb._destroyed = true
						end

						pt(vm.Parent)
					end)

					pt(vm.Parent)

					-- // REMOVING

					_G.ECON_VARS.VMS_CONS[name][2] = vm:GetPropertyChangedSignal('Parent'):Once(function()
						if not vm.Parent then
							pt()
							for _, v in _G.ECON_VARS.VMS_CONS[name] do
								v:Disconnect()
							end
							_G.ECON_VARS.VMS_CONS[name] = nil
						end
					end)

					-- // ADD

					if vm == vms:GetChildren()[1] and _G.frr then
						_G.frr()
					end

					-- // Unimportant [ Effects ]

					task.spawn(function()
						-- // AIMING CHECK

						local itemint = plr.PlayerGui.MainGui.MainFrame.ItemInterfaces:WaitForChild(plr.Name.. ' - '..spl[2])

						local function set(arg1)
							local scope = itemint.Mouse.Scope
							local tbl = {
								BlurImage = scope.Blur.ImageLabel,
								CircleImage = scope.Circle.ImageLabel,
								ReticleDotUICorner = scope.Reticle.Container.Dot.UICorner,
								_dont_rotate_scope_while_sliding = false
							}

							arg1 = tbl

							-- // Scopes

							local scopes = {
								['Pixel Sniper'] = function()
									arg1.BlurImage.Image = "rbxassetid://18171031143"
									arg1.BlurImage.ResampleMode = Enum.ResamplerMode.Pixelated
									arg1.CircleImage.Image = "rbxassetid://18171045114"
									arg1.CircleImage.ResampleMode = Enum.ResamplerMode.Pixelated
									arg1.ReticleDotUICorner:Destroy()
								end, Keyper = function()
									arg1.BlurImage.Image = "rbxassetid://129335242148588"
									arg1.BlurImage.Size = UDim2.new(1.25, 0, 1.25, 0)
									arg1.CircleImage.Image = "rbxassetid://81498448678518"
									arg1.CircleImage.Size = UDim2.new(1.25, 0, 1.25, 0)
									arg1._dont_rotate_scope_while_sliding = true
								end, ['Pixel Crossbow'] = function()
									arg1.CircleImage.Image = "rbxassetid://97622703342015"
									arg1.CircleImage.ResampleMode = Enum.ResamplerMode.Pixelated
									arg1.ReticleDotUICorner:Destroy()
								end,
							}

							if scopes[skinName] then
								scopes[skinName]()
							end
						end

						set()

						local vig = itemint.AimingVignette

						local last = vig.ImageTransparency
						local aiming = false

						local function aimingCallback(v)
							local funcs = {
								['AKEY-47'] = function()
									local var5 = v and .1 or 0
									UTILS.RIVALS_UTILS:CreateSound("rbxassetid://96253147006478", 0.375, 2 + var5, true, var5)
								end,
							}

							if funcs[skinName] then
								funcs[skinName]()
							end
						end

						-- // Aiming Connection

						_G.ECON_VARS.VMS_CONS[name][4] = vig:GetPropertyChangedSignal('ImageTransparency'):Connect(function()
							local _c = aiming
							if vig.ImageTransparency > last and aiming then
								aiming = false
							elseif vig.ImageTransparency < last and not aiming then
								aiming = true
							end

							if aiming ~= _c and math.abs(last-vig.ImageTransparency) < .8 then aimingCallback(aiming) end

							last = vig.ImageTransparency
						end)
					end)
				end
			end)
		end

		local first = vms:GetChildren()[1]
		local z = first and first.Name:split' - '
		if first and z[1] == plr.Name and z[2] == ogitem then
			apl(first)
		end

		for _, v in rep.Assets.Temp.ViewModels:GetChildren() do
			local z = v.Name:split' - '
			if v and z[1] == plr.Name and z[2] == ogitem then
				apl(v)
			end
		end
	end)
end

-- // Skinchanger Save

readsfile()
READ_FILE = true

-- // Rest

cchar()
table.insert(initConnections, plr.CharacterAdded:Connect(cchar))
_G.ac = applySkin

queue_on_teleport(game:HttpGet(URL_ROOT..'MainSkin'))

return module
